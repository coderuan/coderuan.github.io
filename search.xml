<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java集合框架</title>
      <link href="/2020/07/22/java-ji-he-kuang-jia-collection/"/>
      <url>/2020/07/22/java-ji-he-kuang-jia-collection/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Java集合框架"><a href="#一、Java集合框架" class="headerlink" title="一、Java集合框架"></a>一、Java集合框架</h2><ul><li>Java 集合框架主要包括两种类型的容器：<ul><li>一种是集合（Collection），存储一个元素集合</li><li>另一种是图（Map），存储键/值对映射</li></ul></li></ul><p>🙏java集合框架位于 <strong>java.util</strong> 包中，开头先放个图：</p><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/JavaSE/Java_Collection.gif" alt="Collection" style="zoom:80%;" /><p>⭕🔴<strong>Map没有继承Collection接口</strong></p><ul><li>Produces(翻译：产物)： —— 上图的箭头<code>Map———&gt;Collection</code>表示Map可以生成Collection<ul><li>Map是用<strong>key-value</strong>的形式保存值的，而Collection是单value</li><li>即Map的：<ul><li>key可以转化成Collection的Set（Map的key不能重复，这就是Set的特点）</li><li>value可以转化为Collection的List（Map的value可重复，所以符合List）</li></ul></li></ul></li></ul><p>💭简单提一下Iterator迭代器，就是遍历输出，类似for语句，下面再介绍。</p><hr><p>🚩图中的右下角表示工具类：</p><p><strong>Collections</strong>：为所有直接或间接实现了Collection接口的集合类的工具类，该类封装了对集合的各种操作，如<strong>排序、反转、替换</strong>等操作。</p><p><strong>Arrays</strong>：类Arrays为集合的工具类，可使用该类的方法对集合<strong>进行排序、转换为list</strong>等操作。</p><hr><p>集合框架是一个用来代表和操纵集合的统一架构，包含以下内容：</p><ul><li><strong>接口：</strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。<ul><li>之所以定义多个接口，是为了以不同的方式操作集合对象</li></ul></li><li><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构。<ul><li>例如：ArrayList、LinkedList、HashSet、HashMap。</li></ul></li><li><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。<ul><li>这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li></ul></li></ul><p>⚫除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。</p><hr><h2 id="二、Collection"><a href="#二、Collection" class="headerlink" title="二、Collection"></a>二、Collection</h2><p>集合：用于<strong>存储对象</strong>的容器。集合中可以存储任意类型的对象，长度可变。</p><h3 id="2-1、集合的特点"><a href="#2-1、集合的特点" class="headerlink" title="2.1、集合的特点"></a>2.1、集合的特点</h3><p>（1）集合中存储的元素是<strong>对象</strong></p><p>（2）集合的<strong>长度是可变的</strong></p><p>（3）集合<strong>不可以存储基本数据类型</strong></p><table><thead><tr><th>集合和数组的对比：</th><th>数组</th><th>集合</th></tr></thead><tbody><tr><td>长度</td><td>长度固定</td><td>长度可变(根据加载因子和扩容增量来完成扩容)</td></tr><tr><td>存储</td><td>存储基本数据类型或引用类型</td><td>存储引用类型</td></tr><tr><td>元素类型</td><td>元素类型必须一致</td><td>元素类型可以不一致</td></tr><tr><td>操作难度</td><td>操作复杂</td><td>操作简单（包装有现成的方法）</td></tr></tbody></table><hr><h3 id="2-2、Collection简述"><a href="#2-2、Collection简述" class="headerlink" title="2.2、Collection简述"></a>2.2、Collection简述</h3><ul><li>集合是用于存储对象的容器。<ul><li>而每种容器内部都有其独特的数据结构，正因为不同的容器内部数据结构不同，使其各自有自己独特的使用场景。</li><li>虽然每个容器有其独特的结构但是类似的容器还是存在共性的（至少对容器内部对象的操作方法上是存在共性的），所以这些共性方法能被不断抽取，最终形成了集合框架体系。</li></ul></li></ul><hr><h5 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h5><p>List是一个继承于Collection的接口，即List是集合中的一种。List是<strong>有序的队列</strong>，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和Set不同，List中允许有重复的元素。</p><ul><li><strong>List</strong>：实现了Collection接口，存储的数据是有序的、可重复的，可通过索引进行元素访问。<ul><li><strong>ArrayList</strong>：底层实现为<strong>数组</strong>，线程不安全，查找效率高，增删效率低。<ul><li>比较常用的类，一个动态扩容的数组队列；</li><li>它继承于AbstractList，实现了List, RandomAccess, Cloneable, Serializable接口；<ul><li>实现RandomAccess，获得了快速随机访问存储元素的功能，RandomAccess是一个标记接口，没有任何方法；</li><li>实现Cloneable，得到了clone()方法，可以实现克隆功能；</li><li>实现Serializable，表示可以被序列化，通过序列化去传输，典型的应用就是hessian协议；</li></ul></li><li>自动扩容，默认扩容系数为1，每次扩容使用位运算左移一位（即当前容量乘以二）</li><li>插入的元素可以为null</li></ul></li><li><strong>Vector</strong>：vector和ArrayList实现原理相同<ul><li>但是vector是<strong>线程安全</strong>的(synchronized)，效率略低于ArrayList。</li></ul></li><li><strong>Stack</strong>：继承Vector，是一个<strong>先进后出的栈</strong>。<ul><li>除了由Vector定义的所有方法，自己也定义了一些方法：<ul><li><code>boolean empty()//测试堆栈是否为空</code> </li><li><code>Object peek()//查看堆栈顶部的对象,但不从堆栈中移除它</code></li><li><code>Object pop()//移除堆栈顶部的对象,并作为此函数的值返回该对象</code></li><li><code>Object push(Object element)//把对象压入堆栈顶部</code></li><li><code>int search(Object element)//返回对象在堆栈中的位置,以 1 为基数</code></li></ul></li></ul></li><li><strong>LinkedList</strong>：底层实现为<strong>双向链表</strong>，进行元素的增删效率高，查询效率低。<ul><li>每一个节点都拥有指向前后节点的引用；</li><li>相比于ArrayList来说，LinkedList的随机访问效率更低；</li><li>它继承AbstractSequentialList，实现了List, Deque, Cloneable, Serializable接口。<ul><li>LinkedList实现Deque，Deque 是一个双向队列，也就是既可以先入先出，又可以先入后出，说简单些就是既可以在头部添加元素，也可以在尾部添加元素；</li><li>LinkedList实现Cloneable，得到了clone()方法，可以实现克隆功能；</li><li>LinkedList实现Serializable，表示可以被序列化，通过序列化去传输</li></ul></li></ul></li></ul></li></ul><p><strong>模仿一下源码做一下：</strong></p><ol><li>创建一个集合的上层接口：</li></ol><pre><code>package com.wenah;//我们给它设置一些常规增删改查的方法。public interface List {    //{ps} 添加元素到集合中。    boolean add(Object obj);    //{ps} 插入元素到集合中。    boolean insert(int index, Object obj);    //{ps} 移除元素。    Object remove(int index);    //{ps} 获取元素。    Object get(int index);    //{ps} 修改元素。    boolean set(int index, Object obj);    //{ps} 获取元素的个数。    int size();    //{ps} 打印所有元素。    void printList();}</code></pre><ol start="2"><li>编写实现类：</li></ol><pre><code>package com.wenah;/* * 这一个就是顺序结构的线性表 * */public class ArrayList implements List {    //{1} 设置一组存储单元: Object[]    private Object[] data;    //{2} 定一个初始大小: 10    private static final int INIT_CAPACITY = 10;    //{3} 定一个 size :  有几个元素 (实际元素)。    private int size = 0;    public ArrayList(){        this( INIT_CAPACITY );    //默认大小设为10    }    public ArrayList(int capacity){        this.data = new Object[ capacity ];    //自定义大小    }    @Override    public int size() {        return this.size;    }    /*    [1]添加元素：    空间充足 ---&gt; 添加元素(末尾)            空间不够 ---&gt; 进行扩容: ensurecapacity();        新长度 = 旧长度 * 1.5        旧数组的元素复制到新数组上        新元素 ---&gt; 添加元素(末尾)    */    @Override    public boolean add(Object obj) {        if( size+1&gt;data.length ){            ensurecapacity();        }        data[ size ] = obj;        size ++;        return true;    }    private void ensurecapacity() {        System.out.println(&quot;{debug} 调用了ensurecapacity().&quot;);        Object[] newObj = new Object[ (int)(size*1.5) ];        copyArray( data, newObj, 0,data.length );        //旧数组的元素复制到新数组上copyArray:        //for (int i = 0; i &lt; data.length; i++) {        //    newObj[i] = data[i];        //}        data = newObj;    }    private void copyArray( Object[] src, Object[] dest,            int start,int end ){        for (int i = start; i &lt; data.length; i++) {            dest[i] = data[i];        }    }    @Override    public Object get(int index) {        if( index&lt;0 || index&gt;this.size() ) {            System.out.println(&quot;{debug} 超出范围&quot;);            return null;        }        return this.data[index];    }    @Override    public void printList() {        for (int i = 0; i &lt; this.size(); i++) {            if(i%5==0) {                System.out.println(&quot;&quot;);            }            System.out.printf(&quot;第%d个 :  %s , &quot;,i,data[i] );        }        System.out.printf(&quot;\b\b  \n&quot;);    }    @Override    public boolean insert(int index, Object obj) {        if( size+1&gt;data.length ){            ensurecapacity();        }        for (int i = size-1; i &gt;=index; i--) {            data[i+1] = data[i];        }        data[index] = obj;        size ++;        return true;    }    @Override    public Object remove(int index) {        if(index&lt;0 || index&gt;size-1) {            return null;        }        Object obj = data[index];        for (int i = index; i &lt;= size-1; i++) {            if(i==size-1) {                data[i] = null;                break;            }            data[i] = data[i+1];        }        size--;        return obj;    }    @Override    public boolean set(int index, Object obj) {        if(index&lt;0 || index&gt;size-1) {            return false;        }        data[index] = obj;        return false;    }}</code></pre><ol start="3"><li>测试一下：</li></ol><pre><code>package com.wenah;public class TestMain {    public static void main(String[] args) {        List list = new ArrayList();        list.add(&quot;aaa&quot;);        list.add(&quot;bbb&quot;);        list.add(&quot;ccc&quot;);        list.add(&quot;ddd&quot;);        list.printList();        list.insert(1, &quot;ruan&quot;);        list.printList();        list.set(1, &quot;wenah&quot;);        list.printList();        list.remove(1);        list.printList();        System.out.println( &quot;size: &quot;+ list.size() );    }}</code></pre><hr><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Set是一个继承于Collection的接口，即Set也是集合中的一种。Set是没有重复元素的集合。</p><ul><li><strong>Set</strong>:存储的元素是无序的、唯一的。在程序运行中，如果使用add添加一个已经存在的元素，将返回false。<ul><li><strong>HashSet</strong>：底层实现为哈希表(链表+数组)<ul><li>线程不安全，查找效率高，增删效率低，通过元素的hashCode和equels方法保证了元素的唯一性；</li><li>当一条链上元素超过8个以上后，会自动转换为红黑树来存储元素，提高查询效率。</li></ul></li><li><strong>TreeSet</strong>：底层实现为二叉树<ul><li>线程不安全，可对元素进行自动排序</li><li>保证元素唯一性的方式是compareTo方法返回0。</li></ul></li><li><strong>LinkedHashSet</strong>：底层实现为链表和哈希表<ul><li>线程不安全，存储的元素时有序的、唯一的；</li><li>通过元素的hashCode和equels方法保证了元素的唯一性。</li></ul></li></ul></li></ul><hr><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue:"></a>Queue:</h5><ul><li>队列，先进先出(FIFO)<ul><li>队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操；</li><li>LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</li></ul></li></ul><p>Queue以及Deque都是继承于Collection，Deque是Queue的子接口。</p><p>基于它单向队列的特性，可以用在在生产者消费者模式上。</p><p>💨利用阻塞队列BlockingQueue实现生产者消费者模式：</p><ol><li>生产者：</li></ol><pre><code>package com.wenah.testThread;import java.util.Random;import java.util.concurrent.BlockingQueue;public class Produce implements Runnable{    private final BlockingQueue&lt;Integer&gt; queue;    public Produce(BlockingQueue&lt;Integer&gt; q) {        this.queue = q;    }    @Override    public void run() {        try {            while (true) {                Thread.sleep(1000);                queue.put(produce());            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }    private Integer produce() {        int i = new Random().nextInt(10)+1;        System.out.println(&quot;[生产者]当前线程:&quot;+Thread.currentThread().getId()+&quot;————&gt;生产：&quot;+i);        return i;    }}</code></pre><ol start="2"><li>消费者：</li></ol><pre><code>package com.wenah.testThread;import java.util.concurrent.BlockingQueue;public class Customer implements Runnable{    private final BlockingQueue&lt;Integer&gt; queue;    public Customer(BlockingQueue&lt;Integer&gt; q) {        this.queue = q;    }    @Override    public void run() {        try {            while (true) {                Thread.sleep(2000);                int i = queue.take();                System.out.println(&quot;[消费者]当前线程:&quot;+Thread.currentThread().getId() +&quot;————&gt;消费：&quot;+i);            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><ol start="3"><li>测试方法:</li></ol><pre><code>package com.wenah.testThread;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;public class TestMain {    public static void main(String[] args) {        BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(100);        Produce p = new Produce(queue);        Customer c1 = new Customer(queue);        Customer c2 = new Customer(queue);        new Thread(p).start();        new Thread(c1).start();        new Thread(c2).start();    }}</code></pre><hr><h5 id="主要方法："><a href="#主要方法：" class="headerlink" title="主要方法："></a>主要方法：</h5><p>在java1.8的版本中包含了18个方法：</p><pre><code>public interface List&lt;E&gt;extends Collection&lt;E&gt;{}//方法介绍:add(E e)：返回值是boolean,添加一个元素addAll( Collection&lt;? extend E&gt; c )：返回值是boolean类型，将集合C中的所有元素添加到此集合。clear()：返回值是void,删除此集合中的所有元素contains( Object o)：如果包含元素O则返回为truecontainsAll( Collection&lt;?&gt; c):如果包含集合C返回为trueequals( Object o):将指定的对象与此集合进行比较已获得相等性hashCode():返回类型是int，返回此集合的哈希码值isEmpty():如果集合为空则返回trueitreator()：返回此集合元素的迭代器。remove(Object o)：返回类型是boolean,删除指定的元素removeIf(Predicte&lt;? super E&gt; filter):删除满足条件的所有元素removeAll(Collection&lt;?&gt; c)：返回类型是boolean,删除包含集合c的所有元素。size()：返回类型是int，返回此集合的元素数量toArray():返回类型是Object[] ，将此集合转化为数组stream():返回类型是Stream&lt;E&gt;,返回以此集合作为源的顺序流spliterator()：创建一个Spliterator在这个集合中。</code></pre><p>注意：Spliterator（splitable iterator可分割迭代器）接口是Java为了并行遍历数据源中的元素而设计的迭代器，这个可以类比最早Java提供的顺序遍历迭代器Iterator，但一个是顺序遍历，一个是并行遍历。他是从java1.8的版本中开始加进去的。</p><hr><h3 id="2-3、Collection中的迭代器Iterator"><a href="#2-3、Collection中的迭代器Iterator" class="headerlink" title="2.3、Collection中的迭代器Iterator"></a>2.3、Collection中的迭代器Iterator</h3><h5 id="首先介绍下Iterable接口"><a href="#首先介绍下Iterable接口" class="headerlink" title="首先介绍下Iterable接口"></a>首先介绍下Iterable接口</h5><p>iterator()方法是java.lang.Iterable接口,被Collection继承。</p><p>Iterable接口是java 集合框架的顶级接口，实现此接口使集合对象可以通过迭代器<strong>遍历自身元素</strong>，它的成员方法：</p><table><thead><tr><th><strong>修饰符和返回值</strong></th><th><strong>方法名</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Iterator&lt;T&gt;</td><td><strong>iterator</strong>()</td><td>返回一个内部元素为T类型的迭代器</td></tr><tr><td>default void</td><td><strong>forEach</strong>(Consumer&lt;? super T&gt; action)</td><td>对内部元素进行遍历,并对元素进行指定的操作</td></tr><tr><td>default Spliterator&lt;T&gt;</td><td><strong>spliterator</strong>()</td><td>创建并返回一个可分割迭代器</td></tr></tbody></table><ul><li>Iterable最早出现在JDK 1.5，开始只有iterator()一个抽象方法；<ul><li>需要子类来实现一个内部迭代器Iterator遍历元素。</li></ul></li><li>后两个方法是Java 8后新添加的；<ul><li>forEach(Consumer action)是为了方便遍历操作集合内的元素；</li><li>spliterator()则提供了一个可以并行遍历元素的迭代器，以适应现在cpu多核时代并行遍历的需求。</li></ul></li></ul><hr><p>另外：</p><p><code>public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {}</code></p><p><strong>ListIterator</strong>（相比于Iterator，它新增了<strong>添加</strong>、<strong>是否存在上一个元素</strong>、<strong>获取上一个元素</strong>等等API接口）</p><hr><h5 id="接着说下迭代器的使用"><a href="#接着说下迭代器的使用" class="headerlink" title="接着说下迭代器的使用"></a>接着说下迭代器的使用</h5><ul><li>Collection实现了Iterable接口，表明集合都是<strong>可迭代的</strong>；<ul><li>功能比较简单，并且只能单向移动；</li><li>可以用iterable()方法获取集合对应的迭代器；</li><li>也可以使用增强的for循环进行迭代。</li></ul></li></ul><p>⭕增强for循环<strong>内部是使用的Iterator来遍历</strong>的，只能遍历<strong>数组</strong>和<strong>实现了Iterable接口的集合</strong>。</p><ul><li><p>优点是写法简便，无需获得数组、集合长度，也无需根据索引来访问元素</p></li><li><p>缺点是不能在循环里动态的删除元素和获取元素下标。</p></li></ul><p>💦<strong>使用Iterator迭代：</strong></p><p>(1) iterator()：容器返回一个Iterator。</p><p>(2) next()：获得序列中的下一个元素并返回。第一次调用Iterator的next()方法，它返回序列的第一个元素。</p><p>(3) hasNext()：检查序列中是否还有元素，返回boolean型数据。</p><p>(4) remove()：删除元素并返回的删除的元素。</p><pre><code>List list = new ArrayList();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;c&quot;);list.add(&quot;d&quot;);//迭代器迭代Iterator iter = list.iterator();while( iter.hasNext()){    String str = (String)iter.next();    System.out.println(str);}//foreach迭代for(String s : list) {    System.out.println(s);}</code></pre><ul><li>❗进行迭代遍历的时候我们需要注意这种情况，就是在遍历的过程中，如果<strong>对元素进行添加删除</strong>，那么会造成并行修改异常(ConcurrentModificationException)<ul><li>Iterator遍历Collection时，是fail-fast机制的。</li><li>即当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</li></ul></li></ul><p>如下：</p><pre><code>Iterator&lt;Integer&gt; iterator = list.iterator();while(iterator.hasNext()){    Integer i = iterator.next();    if (i == 2) {        list.remove(i);//这样移除是不正确的    }}//对于这种情况,我们应当使用迭代器Iterator内部的remove()方法,//而不是使用集合list直接删除元素,正确写法为Iterator&lt;Integer&gt; iterator = list.iterator();    while (iterator.hasNext()) {    Integer i = iterator.next();    if (i == 2) {        iterator.remove();    //使用迭代器的remove()方法进行删除元素    }}</code></pre><hr><h5 id="最后介绍下实现Iterable接口"><a href="#最后介绍下实现Iterable接口" class="headerlink" title="最后介绍下实现Iterable接口"></a>最后介绍下实现Iterable接口</h5><ul><li>如果自己写一个集合：实现Iterable接口，并可以使用<strong>增强型for语句</strong>形式遍历。<ul><li>那么需要<strong>重写</strong>一个迭代器(Iterator)并返回它，如下：</li></ul></li></ul><pre><code>public class MyCollection&lt;E&gt; implements Iterable&lt;E&gt; {    @Override    public Iterator iterator() {        return new MyIterator();//返回一个迭代器对象    }    //在这里实现集合的方法    //使用内部类MyIterator    private class MyIterator implements Iterator&lt;E&gt;{        /*            为了使用增强的for循环,            需要重写hasNext()、next()        */        @Override        public boolean hasNext() {            return false;    //实现方法,返回一个boolean类型数据        }        @Override        public E next() {            return null;    //实现方法,返回下一个要取的数据        }    }}</code></pre><hr><h2 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h2><p>Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p><ul><li>key底层就算set实现的，映射到value上</li><li>value底层就是一个链表</li></ul><p>🙃先不写了，把框架复习一下，准备一下面试吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基础知识，要牢固！</p><blockquote><p><a href="https://www.cnblogs.com/bushi/p/6647006.html" target="_blank" rel="noopener">java 集合框架(二)Iterable接口</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP简述</title>
      <link href="/2020/07/19/tcp-ip/"/>
      <url>/2020/07/19/tcp-ip/</url>
      
        <content type="html"><![CDATA[<h2 id="一、TCP-IP简述"><a href="#一、TCP-IP简述" class="headerlink" title="一、TCP/IP简述"></a>一、TCP/IP简述</h2><p>TCP/IP 是用于因特网 (Internet) 的通信协议。</p><h3 id="1-1、什么是-TCP-IP？"><a href="#1-1、什么是-TCP-IP？" class="headerlink" title="1.1、什么是 TCP/IP？"></a>1.1、什么是 TCP/IP？</h3><ul><li>TCP/IP 指 <strong>传输控制协议</strong> <strong>/</strong> <strong>网际协议</strong>（Transmission Control Protocol / Internet Protocol）<ul><li>供已连接因特网的计算机进行通信的通信协议</li><li>定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准</li></ul></li></ul><p>⭕TCP/IP 意味着 TCP 和 IP 在一起协同工作。</p><ul><li><p>TCP 负责应用软件（比如浏览器）和网络软件之间的通信。</p></li><li><p>IP 负责计算机之间的通信。</p></li><li><p>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。</p></li><li><p>IP 负责将包发送至接受者。</p></li></ul><hr><p>⚫在 TCP/IP 中包含一系列用于<strong>处理数据通信</strong>的协议：</p><ul><li>TCP (传输控制协议) - <strong>应用程序之间</strong>通信</li><li>UDP (用户数据报协议) - 应用程序之间的简单通信</li><li>IP (网际协议) - <strong>计算机之间</strong>的通信</li><li>ICMP (因特网消息控制协议) - 针对错误和状态</li><li>DHCP (动态主机配置协议) - 针对动态寻址</li></ul><hr><h3 id="1-2、TCP-：用于应用程序之间的通信（TCP-使用固定的连接）"><a href="#1-2、TCP-：用于应用程序之间的通信（TCP-使用固定的连接）" class="headerlink" title="1.2、TCP ：用于应用程序之间的通信（TCP 使用固定的连接）"></a>1.2、TCP ：用于应用程序之间的通信（TCP 使用固定的连接）</h3><ul><li><p>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方”<strong>握手</strong>“之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。</p><ul><li>比如DNF的pk场对战，两个用户的客户端之间的通信</li></ul></li><li><p>这个<strong>全双工的通信</strong>将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p><ul><li>全双工（Full Duplex）是通讯传输的一个术语。通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。</li><li>半双工就是指一个时间段内只有一个动作发生，举个简单例子，一条窄窄的马路，同时只能有一辆车通过，当目前有两辆车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开，这个例子就形象的说明了半双工的原理。</li><li>单工就是在只允许甲方向乙方传送信息，而乙方不能向甲方传送 。（比喻汽车的单行道。）</li></ul></li></ul><hr><p>补充：<strong>UDP和TCP很相似</strong>，但是更简单，同时可靠性低于 TCP（与TCP相互补充使用）</p><ul><li>UDP 是User Datagram Protocol 的简称， 中文名是<strong>用户数据报协议</strong><ul><li>一种无连接的<a href="https://baike.baidu.com/item/传输层" target="_blank" rel="noopener">传输层</a>协议，提供面向事务的简单<strong>不可靠信息传送服务</strong></li></ul></li><li>UDP提供了<strong>无连接通信</strong>，且不对传送数据包进行可靠性保证<ul><li>适合于一次传输少量数据，UDP传输的可靠性由应用层负责</li></ul></li><li>UDP报文<strong>没有可靠性保证</strong>、顺序保证和流量控制字段等，可靠性较差<ul><li>但是正因为UDP协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高</li><li>适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等</li></ul></li><li>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。</li><li>在发送端，UDP<strong>传送数据的速度</strong>仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制</li></ul><p>适用场合：</p><ul><li>在选择UDP作为传输协议时必须要谨慎。<ul><li>在网络质量令人十分不满意的环境下，UDP协议数据包丢失会比较严重。</li></ul></li><li>它不属于连接型协议，因而具有资源消耗小，处理速度快的优点<ul><li>通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</li></ul></li></ul><p>💢简单来说，UDP速度就是快🚀！代价是不可靠🐷！</p><hr><h3 id="1-3、TCP连接（握手和挥手）"><a href="#1-3、TCP连接（握手和挥手）" class="headerlink" title="1.3、TCP连接（握手和挥手）"></a>1.3、TCP连接（握手和挥手）</h3><h5 id="首先是请求连接（3次握手）："><a href="#首先是请求连接（3次握手）：" class="headerlink" title="首先是请求连接（3次握手）："></a>首先是请求连接（3次握手）：</h5><ul><li>TCP 提供面向有连接的通信传输。<ul><li>面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</li></ul></li><li>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。<ul><li>在socket编程中，这一过程由客户端执行connect来触发。</li></ul></li></ul><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpeg" alt="三次握手" title="请和我连接！" style="zoom: 80%;" /><ul><li>第一次握手：<strong>客户端</strong>将标志位SYN置为1，随机产生一个值seq=J<ul><li>将该数据包<strong>发送给服务器端</strong>，客户端进入SYN_SENT状态，等待服务器端确认</li></ul></li><li>第二次握手：<strong>服务器端收到数据包后</strong>由标志位SYN=1知道客户端请求建立连接<ul><li><strong>服务器</strong>端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K</li><li>并将该数据包<strong>发送给客户端</strong>以确认连接请求，服务器端进入SYN_RCVD状态</li></ul></li><li>第三次握手：<strong>客户端收到确认后</strong>，检查ack是否为J+1，ACK是否为1<ul><li>如果正确则将标志位ACK置为1，ack=K+1，并将该数据包<strong>发送给服务器端</strong></li><li>服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功</li><li>客户端和服务器端进入ESTABLISHED状态，完成三次握手，客户端与服务器端之间可以开始传输数据了</li></ul></li></ul><hr><p>🙋‍♂️简单来说和打电话类似：</p><ul><li><p><strong>第一次：喂？你好！我！张三！法外狂徒！</strong>（客户端👉服务器）</p><ul><li>（喂？你好！）<ul><li>客户端请求与服务器进行连接</li></ul></li><li>（我！张三！法外狂徒！）<ul><li>客户端<strong>发送</strong>一个数据包（我！张三！法外狂徒！），等待服务器端回应</li></ul></li></ul></li><li><p><strong>第二次：嗯嗯。有事？</strong>（客户端👈服务器）</p><ul><li>（嗯嗯。）<ul><li>服务器端<strong>收到</strong>了数据包（我！张三！法外狂徒！），并确认了</li></ul></li><li>（有事？）<ul><li>服务器端<strong>确认</strong>了数据包（我！张三！法外狂徒！）之后，</li><li>服务器端<strong>发送</strong>另外一个数据包（有事？）确认连接请求</li></ul></li></ul></li><li><p><strong>第三次：对！</strong>（客户端👉服务器）</p><ul><li>（对！）<ul><li>客户端<strong>收到</strong>数据包（有事？），确认后，<strong>发送</strong>一个数据包（对！）</li><li>服务器端<strong>收到</strong>数据包（对！），确认后，连接建立成功👫</li></ul></li></ul></li><li><p>🙏然后！双方都准备好了……开始对话💑</p></li></ul><hr><h5 id="然后是请求终止连接（4次挥手）："><a href="#然后是请求终止连接（4次挥手）：" class="headerlink" title="然后是请求终止连接（4次挥手）："></a>然后是请求终止连接（4次挥手）：</h5><ul><li>四次挥手即终止TCP连接，断开一个TCP连接时，需要客户端和服务端总共<strong>发送4个包</strong>以确认连接的断开<ul><li>在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</li></ul></li><li>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭<ul><li>这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了。</li><li>但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。</li><li>首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</li></ul></li></ul><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpeg" alt="四次挥手" title="我们断开吧！" style="zoom:80%;" /><ul><li>中断连接端可以是客户端，也可以是服务器端。</li><li>第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li><li>第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</li><li>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。</li><li>第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li></ul><hr><p>🙋‍♂️简单来说和打电话类似：</p><ul><li>第一次：我说完了</li><li>第二次：好的，我知道了。</li><li>第三次：我也说完了。</li><li>第四次：好的，你可以挂了。（等待2MSL，没回复，我也挂了。）</li></ul><hr><p><strong>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况：</strong></p><p>具体流程如下图：<img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/%E5%90%8C%E6%97%B6%E6%8C%A5%E6%89%8B.jpeg" alt="四次挥手" title="我们断开吧！" style="zoom:80%;" /></p><hr><h3 id="1-4、IP-：用于计算机之间的通信（IP-是无连接的）"><a href="#1-4、IP-：用于计算机之间的通信（IP-是无连接的）" class="headerlink" title="1.4、IP ：用于计算机之间的通信（IP 是无连接的）"></a>1.4、IP ：用于计算机之间的通信（IP 是无连接的）</h3><ul><li><p>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。</p><ul><li>这样，IP 就降低了对网络线路的需求。</li><li>每条线可以同时满足许多不同的计算机之间的通信需要。</li></ul></li><li><p>通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。</p><ul><li>IP 负责将每个包路由至它的目的地。</li><li>网络上经常说的丢包，就是这个包（就是你网络不好，卡比😂）</li></ul></li></ul><hr><h3 id="1-5、IP-路由器"><a href="#1-5、IP-路由器" class="headerlink" title="1.5、IP 路由器"></a>1.5、IP 路由器</h3><p>当一个 IP 包从一台计算机被发送，它会到达一个 IP 路由器。</p><p>IP 路由器负责将这个包<strong>路由至它的目的地</strong>，直接地或者通过其他的路由器。</p><p>在一个相同的通信中，一个包所经由的路径可能会和其他的包不同。而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址。</p><hr><h2 id="二、TCP-IP寻址"><a href="#二、TCP-IP寻址" class="headerlink" title="二、TCP/IP寻址"></a>二、TCP/IP寻址</h2><h3 id="2-1、IP地址"><a href="#2-1、IP地址" class="headerlink" title="2.1、IP地址"></a>2.1、IP地址</h3><ul><li><p>每个计算机必须有一个 IP 地址才能够连入因特网。</p></li><li><p>每个 IP 包必须有一个地址才能够发送到另一台计算机。</p></li></ul><pre><code>win+R 调出命令行工具，可以使用ping指令查看，比如本站C:\Users\wenah阮&gt;ping www.coderuan.cn正在 Ping www.coderuan.cn [185.199.110.153] 具有 32 字节的数据:来自 185.199.110.153 的回复: 字节=32 时间=968ms TTL=50来自 185.199.110.153 的回复: 字节=32 时间=1210ms TTL=50来自 185.199.110.153 的回复: 字节=32 时间=1133ms TTL=50来自 185.199.110.153 的回复: 字节=32 时间=861ms TTL=50185.199.110.153 的 Ping 统计信息:    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位):    最短 = 861ms，最长 = 1210ms，平均 = 1043ms</code></pre><hr><h3 id="2-2、IP-地址包含-4-组数字："><a href="#2-2、IP-地址包含-4-组数字：" class="headerlink" title="2.2、IP 地址包含 4 组数字："></a>2.2、IP 地址包含 4 组数字：</h3><p>TCP/IP 使用 4 组数字来为计算机编址。每个计算机必须有一个唯一的 4 组数字的地址。</p><p>每组数字必须在 0 到 255 之间，并由点号隔开，比如本站：<strong>185.199.110.153</strong>。</p><hr><h3 id="2-3、TCP-IP-使用-32-个比特来编址"><a href="#2-3、TCP-IP-使用-32-个比特来编址" class="headerlink" title="2.3、TCP/IP 使用 32 个比特来编址"></a>2.3、TCP/IP 使用 32 个比特来编址</h3><ul><li>一个计算机字节是 8 比特。</li><li>32 比特 = 4 字节，所以 TCP/IP 使用了 4 个字节。</li></ul><p>一个计算机字节可以包含 256 个不同的值：</p><p>00000000、00000001、00000010、00000011、00000100、00000101、00000110、00000111、00001000 ……. 直到 11111111。</p><p>即 TCP/IP 地址是介于 0 到 255 之间的 4 组数字。</p><hr><h3 id="2-3、IPV6"><a href="#2-3、IPV6" class="headerlink" title="2.3、IPV6"></a>2.3、IPV6</h3><ul><li><p>IPv6 是 “Internet Protocol Version 6” 的缩写，也被称作下一代互联网协议</p><ul><li>它是由 IETF 小组（Internet 工程任务组Internet Engineering Task Force）设计的用来替代现行的 IPv4（现行的）协议的一种新的 IP 协议。</li></ul></li><li><p>Internet 的主机都有一个唯一的 IP 地址，IP 地址用一个 32 位二进制的数表示一个主机号码，但 32 位地址资源有限，已经<strong>不能满足用户的需求</strong>了，因此 Internet 研究组织发布新的主机标识方法，即 IPv6。</p><ul><li>就算原来的地址不够用了😄，所有从32位扩展到128位来迎接接下来的万物互联😮</li></ul></li></ul><p>在 RFC1884 中（RFC 是 Request for Comments document 的缩写。RFC 实际上就是 Internet 有关服务的一些标准），规定的标准语法建议把 IPv6 地址的 128 位（16 个字节）写成 8 个 16 位的无符号整数，每个整数用 4 个十六进制位表示，这些数之间用冒号（:）分开，例如：</p><p><code>686E：8C64：FFFF：FFFF：0：1180：96A：FFFF</code></p><p>冒号十六进制记法允许零压缩，即一串连续的0可以用一对冒号取代，例如：</p><p><code>FF05：0：0：0：0：0：0：B3可以定成：FF05：：B3</code></p><p>为了保证零压缩有一个清晰的解释，建议中规定，在任一地址中，只能使用一次零压缩。该技术对已建议的分配策略特别有用，因为会有许多地址包含连续的零串。</p><p>冒号十六进制记法结合有点十进制记法的后缀。这种结合在IPv4向IPv6换阶段特别有用。例如，下面的串是一个合法的冒号十六进制记法：</p><p><code>0：0：0：0：0：0：128.10.1.1</code></p><p>这种记法中，虽然冒号所分隔的每一个值是一个16位的量，但每个分点十进制部分的值则指明一个字节的值。再使用零压缩即可得出：</p><p><code>：：128.10.1.1</code></p><hr><h2 id="三、域名"><a href="#三、域名" class="headerlink" title="三、域名"></a>三、域名</h2><p>12 个阿拉伯数字很难记忆。使用一个名称更容易。</p><p>用于 TCP/IP 地址的名字被称为域名。coderuan.cn 就是一个域名。</p><p>当键入一个像 <a href="https://www.coderuan.cn" target="_blank" rel="noopener">https://www.coderuan.cn</a> 这样的域名，域名会被一种 DNS 程序翻译为数字。</p><ul><li><p>在全世界，数量庞大的 DNS 服务器被连入因特网。DNS 服务器负责将域名翻译为 TCP/IP 地址，同时负责使用新的域名信息更新彼此的系统。</p></li><li><p>当一个新的域名连同其 TCP/IP 地址一起注册后，全世界的 DNS 服务器都会对此信息进行更新。</p></li></ul><hr><h2 id="四、TCP-IP-协议"><a href="#四、TCP-IP-协议" class="headerlink" title="四、TCP/IP 协议"></a>四、TCP/IP 协议</h2><ul><li>TCP/IP 是不同的通信协议的大集合<ul><li>基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大集合</li></ul></li></ul><h5 id="3-1、TCP-传输控制协议"><a href="#3-1、TCP-传输控制协议" class="headerlink" title="3.1、TCP - 传输控制协议"></a>3.1、TCP - 传输控制协议</h5><ul><li>TCP 用于从应用程序到网络的数据传输控制。<ul><li>在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。</li></ul></li></ul><h5 id="3-2、IP-网际协议（Internet-Protocol）"><a href="#3-2、IP-网际协议（Internet-Protocol）" class="headerlink" title="3.2、IP - 网际协议（Internet Protocol）"></a>3.2、IP - 网际协议（Internet Protocol）</h5><ul><li>IP 负责计算机之间的通信。<ul><li>在因特网上发送和接收数据包。</li></ul></li></ul><h5 id="3-3、HTTP-超文本传输协议-Hyper-Text-Transfer-Protocol"><a href="#3-3、HTTP-超文本传输协议-Hyper-Text-Transfer-Protocol" class="headerlink" title="3.3、HTTP - 超文本传输协议(Hyper Text Transfer Protocol)"></a>3.3、HTTP - 超文本传输协议(Hyper Text Transfer Protocol)</h5><ul><li>HTTP 负责 web 服务器与 web 浏览器之间的通信。<ul><li>从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。</li></ul></li></ul><h5 id="3-4、HTTPS-安全的-HTTP（HTTP-Secure）"><a href="#3-4、HTTPS-安全的-HTTP（HTTP-Secure）" class="headerlink" title="3.4、HTTPS - 安全的 HTTP（HTTP Secure）"></a>3.4、HTTPS - 安全的 HTTP（HTTP Secure）</h5><ul><li><p>HTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。</p></li><li><p>作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据。</p></li></ul><h5 id="3-5、SSL-安全套接字层（Secure-Sockets-Layer）"><a href="#3-5、SSL-安全套接字层（Secure-Sockets-Layer）" class="headerlink" title="3.5、SSL - 安全套接字层（Secure Sockets Layer）"></a>3.5、SSL - 安全套接字层（Secure Sockets Layer）</h5><ul><li>SSL 协议用于为安全数据传输加密数据。</li></ul><h5 id="3-6、SMTP-简易邮件传输协议（Simple-Mail-Transfer-Protocol）"><a href="#3-6、SMTP-简易邮件传输协议（Simple-Mail-Transfer-Protocol）" class="headerlink" title="3.6、SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）"></a>3.6、SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）</h5><ul><li>SMTP 用于电子邮件的传输。</li></ul><h5 id="3-7、MIME-多用途因特网邮件扩展（Multi-purpose-Internet-Mail-Extensions）"><a href="#3-7、MIME-多用途因特网邮件扩展（Multi-purpose-Internet-Mail-Extensions）" class="headerlink" title="3.7、MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）"></a>3.7、MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）</h5><ul><li>MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。</li></ul><h5 id="3-8、IMAP-因特网消息访问协议（Internet-Message-Access-Protocol）"><a href="#3-8、IMAP-因特网消息访问协议（Internet-Message-Access-Protocol）" class="headerlink" title="3.8、IMAP - 因特网消息访问协议（Internet Message Access Protocol）"></a>3.8、IMAP - 因特网消息访问协议（Internet Message Access Protocol）</h5><ul><li>IMAP 用于存储和取回电子邮件。</li></ul><h5 id="3-9、POP-邮局协议（Post-Office-Protocol）"><a href="#3-9、POP-邮局协议（Post-Office-Protocol）" class="headerlink" title="3.9、POP - 邮局协议（Post Office Protocol）"></a>3.9、POP - 邮局协议（Post Office Protocol）</h5><ul><li>POP 用于从电子邮件服务器向个人电脑下载电子邮件。</li></ul><h5 id="3-10、FTP-文件传输协议（File-Transfer-Protocol）"><a href="#3-10、FTP-文件传输协议（File-Transfer-Protocol）" class="headerlink" title="3.10、FTP - 文件传输协议（File Transfer Protocol）"></a>3.10、FTP - 文件传输协议（File Transfer Protocol）</h5><ul><li>FTP 负责计算机之间的文件传输。</li></ul><h5 id="3-11、NTP-网络时间协议（Network-Time-Protocol）"><a href="#3-11、NTP-网络时间协议（Network-Time-Protocol）" class="headerlink" title="3.11、NTP - 网络时间协议（Network Time Protocol）"></a>3.11、NTP - 网络时间协议（Network Time Protocol）</h5><ul><li>NTP 用于在计算机之间同步时间（钟）。</li></ul><h5 id="3-12、DHCP-动态主机配置协议（Dynamic-Host-Configuration-Protocol）"><a href="#3-12、DHCP-动态主机配置协议（Dynamic-Host-Configuration-Protocol）" class="headerlink" title="3.12、DHCP - 动态主机配置协议（Dynamic Host Configuration Protocol）"></a>3.12、DHCP - 动态主机配置协议（Dynamic Host Configuration Protocol）</h5><ul><li>DHCP 用于向网络中的计算机分配动态 IP 地址。</li></ul><h5 id="3-13、SNMP-简单网络管理协议（Simple-Network-Management-Protocol）"><a href="#3-13、SNMP-简单网络管理协议（Simple-Network-Management-Protocol）" class="headerlink" title="3.13、SNMP - 简单网络管理协议（Simple Network Management Protocol）"></a>3.13、SNMP - 简单网络管理协议（Simple Network Management Protocol）</h5><ul><li>SNMP 用于计算机网络的管理。</li></ul><h5 id="3-14、LDAP-轻量级的目录访问协议（Lightweight-Directory-Access-Protocol）"><a href="#3-14、LDAP-轻量级的目录访问协议（Lightweight-Directory-Access-Protocol）" class="headerlink" title="3.14、LDAP - 轻量级的目录访问协议（Lightweight Directory Access Protocol）"></a>3.14、LDAP - 轻量级的目录访问协议（Lightweight Directory Access Protocol）</h5><ul><li>LDAP 用于从因特网搜集关于用户和电子邮件地址的信息。</li></ul><h5 id="3-15、ICMP-因特网消息控制协议（Internet-Control-Message-Protocol）"><a href="#3-15、ICMP-因特网消息控制协议（Internet-Control-Message-Protocol）" class="headerlink" title="3.15、ICMP - 因特网消息控制协议（Internet Control Message Protocol）"></a>3.15、ICMP - 因特网消息控制协议（Internet Control Message Protocol）</h5><ul><li>ICMP 负责网络中的错误处理。</li></ul><h5 id="3-16、ARP-地址解析协议（Address-Resolution-Protocol）"><a href="#3-16、ARP-地址解析协议（Address-Resolution-Protocol）" class="headerlink" title="3.16、ARP - 地址解析协议（Address Resolution Protocol）"></a>3.16、ARP - 地址解析协议（Address Resolution Protocol）</h5><ul><li>ARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址。</li></ul><h5 id="3-17、RARP-反向地址转换协议（Reverse-Address-Resolution-Protocol）"><a href="#3-17、RARP-反向地址转换协议（Reverse-Address-Resolution-Protocol）" class="headerlink" title="3.17、RARP - 反向地址转换协议（Reverse Address Resolution Protocol）"></a>3.17、RARP - 反向地址转换协议（Reverse Address Resolution Protocol）</h5><ul><li>RARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址。</li></ul><h5 id="3-18、BOOTP-自举协议（Boot-Protocol）"><a href="#3-18、BOOTP-自举协议（Boot-Protocol）" class="headerlink" title="3.18、BOOTP - 自举协议（Boot Protocol）"></a>3.18、BOOTP - 自举协议（Boot Protocol）</h5><ul><li>BOOTP 用于从网络启动计算机。</li></ul><h5 id="3-19、PPTP-点对点隧道协议（Point-to-Point-Tunneling-Protocol）"><a href="#3-19、PPTP-点对点隧道协议（Point-to-Point-Tunneling-Protocol）" class="headerlink" title="3.19、PPTP - 点对点隧道协议（Point to Point Tunneling Protocol）"></a>3.19、PPTP - 点对点隧道协议（Point to Point Tunneling Protocol）</h5><ul><li>PPTP 用于私人网络之间的连接（隧道）。</li></ul><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写着写着想起大学老师的授课了，怀念大学时光<del>~</del></p><p>教练，我要学编程😂</p><hr><blockquote><p><a href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5/310007?fr=aladdin" target="_blank" rel="noopener">百度百科|全双工</a></p><p><a href="https://baike.baidu.com/item/TCP/IP%E5%8D%8F%E8%AE%AE/212915" target="_blank" rel="noopener">百度百科|TCP/IP协议</a></p><p><a href="https://www.runoob.com/tcpip/tcpip-tutorial.html" target="_blank" rel="noopener">TCP/IP 教程</a></p><p><a href="https://developer.51cto.com/art/201906/597961.htm" target="_blank" rel="noopener">太厉害了，终于有人能把TCP/IP协议讲的明明白白了！</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 协议 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session和Cookie</title>
      <link href="/2020/07/19/session-he-cookie/"/>
      <url>/2020/07/19/session-he-cookie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Session"><a href="#一、Session" class="headerlink" title="一、Session"></a>一、Session</h2><h3 id="1-1、什么是HttpSession？"><a href="#1-1、什么是HttpSession？" class="headerlink" title="1.1、什么是HttpSession？"></a>1.1、什么是HttpSession？</h3><ul><li>http协议的一次会话，提供了存储和返回标准会话属性的方法。</li><li>标准会话属性如会话标识符、应用数据等，都以“名字——值”对的形式保存在服务器。</li><li>也就是说，HttpSession接口提供了一种<strong>把对象存到内存</strong>、在统一用户的<strong>后继请求中</strong>提取这些对象的标准方法。</li></ul><p>当用户打开浏览器，访问某个网站时，服务器就会在服务器的内存中为该浏览器分配一个空间，该空间被这个浏览器独占，这个空间就是Session。Session的数据默认存在时间为30分钟（Tomcat），也可以自行修改。</p><h3 id="1-2、Session可以用来做什么？"><a href="#1-2、Session可以用来做什么？" class="headerlink" title="1.2、Session可以用来做什么？"></a>1.2、Session可以用来做什么？</h3><p>1、 网上商城中的购物车</p><p>2、 保存登录的用户信息</p><p>3、 将某些数据放到session中，供同一用户的各个页面使用</p><p>4、 防止用户的非法登录到某个页面</p><p>5、 ……….很多很多😄</p><h4 id="如何使用session"><a href="#如何使用session" class="headerlink" title="如何使用session"></a>如何使用session</h4><ul><li>获得session</li></ul><p><code>HttpSession session = request.getSession();</code></p><pre><code>//参数为true时,若存在会话,则返回该会话,否则 new 一个会话;//参数为false时,如存在会话,则返回该会话,否则返回NULL;getSession(boolean flag)getSession()相当于getSession(true);</code></pre><ul><li>添加值到session</li></ul><p><code>session.setAttribute(String name,Objct val);</code></p><ul><li>从session中获得属性值</li></ul><p><code>String name = session.getAttribute(String name);</code></p><ul><li>从session中删除某个属性</li></ul><p><code>session.removeAttribute(String name);</code></p><ul><li>设置Session的存活期限： </li></ul><p><code>setMaxInactiveInterval(int interval);</code>  </p><p>设置请求间隔时间（单位是秒），当浏览器超出interval秒还没有请求该应用的话就清除该Session。（如果在设定时间内访问，则会从最后一次访问时间点重新开始计算存活时间）</p><p>注意：如果interval为0或负则表示Session可以无限存活（除非关闭Web容器）</p><hr><h2 id="二、Cookie"><a href="#二、Cookie" class="headerlink" title="二、Cookie"></a>二、Cookie</h2><h3 id="2-1、Cookie的起源"><a href="#2-1、Cookie的起源" class="headerlink" title="2.1、Cookie的起源"></a>2.1、Cookie的起源</h3><p>Cookie最早出现在网景公司的雇员Lou Montulli在1993年的时候发明。</p><p>​        Cookie是由服务器端生成，一般发送给浏览器，<strong>浏览器会将cookie的key/value保存到某个目录下</strong>的文本中。Cookie名称和值可以由服务器端自定义，对于JSP而言也可以直接写入jsessionid，这样服务器可以知道该用户是否合法用户以及是否需要重新登录。</p><h4 id="Cookie使用"><a href="#Cookie使用" class="headerlink" title="Cookie使用"></a>Cookie使用</h4><p>1、 创建cookie（服务端创建）</p><p><code>Cookie cook = new Cookie(String key,String value);</code></p><p>2、 将创建好的cookie添加到客户端</p><p><code>response.addCookie(cook);</code></p><p>3、 如何读取cookie(从客户端读取到服务端中)</p><p><code>request.getCookies();</code></p><pre><code>//获取cookie，cookie可能是多个，所以返回一组cookieCookie[] cook = request.getCookies();if(cook!=null){    for(int i=0;i&lt;cook.length;i++){        //获得cookie中的元素        Cookie co = cook[i];        //通过判断是否有需要的cookie，co.getName()获得cookie的名字        if(co.getName().equals(&quot;name&quot;)){            name = co.getValue();    //读取用户名            co.setMaxAge(0);    //时效为0，cookie失效        }        if(co.getName().equals(&quot;pwd&quot;)){            pwd = co.getValue();    //读取密码            co.setMaxAge(0);    //时效为0，cookie失效        }    }}</code></pre><p>4、 设置cookie存在时间</p><p>Cooker.setMaxAge(秒)</p><p>5、 删除cookie，将cookie的SetMaxAge时间设置为0</p><h4 id="Cookie的生命周期"><a href="#Cookie的生命周期" class="headerlink" title="Cookie的生命周期"></a>Cookie的生命周期</h4><ul><li>Cookie可以保持登录信息到用户下次与服务器的会话<ul><li>换句话说，下次访问同一网站时，用户不必输入用户名和密码就可以登陆了。</li></ul></li><li>Cookie在生成时就会<strong>被指定一个expire值</strong>，这就是cookie的生命周期，超出周期cookie就会被清除。<ul><li>有些页面将cookie的生存周期设置为0，这样在关闭页面是，就马上清除cookie，不会记录用户信息，更加安全。</li></ul></li></ul><h4 id="Cookie的优缺点"><a href="#Cookie的优缺点" class="headerlink" title="Cookie的优缺点"></a>Cookie的优缺点</h4><ul><li>优点</li></ul><p><strong>方便用户登陆网站</strong>——保存有用户信息，可用于自动登陆等</p><p><strong>独立的Cookie空间</strong>——在一台计算机中安装多个浏览器，每个浏览器都会在各自独立的空间存放cookie。cookie中不但可以确认用户，还能包含计算机信息和浏览器信息，所以一个用户用不同的浏览器登录或使用不同的计算机登录，都会得到不同的cookie信息。</p><ul><li>缺点</li></ul><p><strong>识别不精确</strong>——对于在同一台计算机上使用同一浏览器的多用户群，cookie不会区分他们的身份，除非他们使用不同的用户名登录</p><p><strong>个人隐私和安全</strong>——因为会保存计算机信息和用户信息，这些都为敏感信息，有可能会被泄露</p><hr><h2 id="三、Session和Cookie的区别"><a href="#三、Session和Cookie的区别" class="headerlink" title="三、Session和Cookie的区别"></a>三、Session和Cookie的区别</h2><h3 id="3-1、存在的位置"><a href="#3-1、存在的位置" class="headerlink" title="3.1、存在的位置"></a>3.1、存在的位置</h3><ul><li>Session对象保存在<strong>服务器</strong>内存中</li><li>Cookie对象保存在<strong>客户端</strong>的硬盘或内存中</li></ul><h3 id="3-2、安全性"><a href="#3-2、安全性" class="headerlink" title="3.2、安全性"></a>3.2、安全性</h3><ul><li>Session的安全性较高，因为它存放于服务端</li><li>Cookie安全性相对较低，因为它保存在客户端，任何人都可以获得你的账号和密码</li></ul><h3 id="3-3、网络传输"><a href="#3-3、网络传输" class="headerlink" title="3.3、网络传输"></a>3.3、网络传输</h3><ul><li>Session因为保存在服务端，不需要传输</li><li>cookie保存在客户端，需要进行网络传输</li></ul><h3 id="3-4、生命周期"><a href="#3-4、生命周期" class="headerlink" title="3.4、生命周期"></a>3.4、生命周期</h3><ul><li><p>Session的生命周期是一个<strong>间隔</strong>，从创建的时候开始计时</p><ul><li>如果在生命周期内没有访问Session，那么Session无效</li><li>如果在生命周期内访问Session，那么它的生命周期<strong>重新计算</strong></li></ul></li><li><p>Cookie的生命周期是<strong>累计</strong>的，从创建的时候开始计时</p><ul><li>生命周期到了之后Cookie的生命周期结束，cookie就无效了</li><li>就算周期内再访问，也<strong>不会重新计时</strong>，不会刷新</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet使用分页技术</title>
      <link href="/2020/07/18/servlet-zhong-shi-yong-fen-ye/"/>
      <url>/2020/07/18/servlet-zhong-shi-yong-fen-ye/</url>
      
        <content type="html"><![CDATA[<h3 id="Servlet中使用分页技术"><a href="#Servlet中使用分页技术" class="headerlink" title="Servlet中使用分页技术"></a>Servlet中使用分页技术</h3><p>为什么要使用分页？</p><ul><li>页面数据过多，无法一次性展示完成，需要分页显示。</li></ul><p>分页的需要准备的数据：</p><ul><li>pageSize 每页多少条数据（程序设定）</li><li>pageNow 当前页（用户点击选择）</li><li>rowCount 一共多少条记录（根据数据库统计所得）</li><li>pageCount 一共多少页（根据总记录和每页记录展示数计算）</li></ul><p>pageCount 需要判断尾页是否为完整页面（展示记录是否刚好等于每页记录数）：</p><p><code>pageCount = rowCount%pageSize&gt;0 ? (rowCount/pageSize)+1 : rowCount/pageSize;</code></p><h4 id="1、页面对象类pageBean"><a href="#1、页面对象类pageBean" class="headerlink" title="1、页面对象类pageBean"></a>1、页面对象类pageBean</h4><pre><code>public class pageBean&lt;T&gt; {    private int rowCount;    // 数据总行数：去数据库查询(如果有模糊查询，根据条件查询)    private int pageSize=1;    // 页面展示行数：根据需求设置展示行数,注意程序的除0异常    private int pageNow;    // 当前页：根据前端点击改变,初次访问设置为1    private int pageCount;    // 页面总数    private List&lt;T&gt; list = new ArrayList&lt;&gt;();    // 存储当前页的数据    public int getRowCount() {        return rowCount;    }    public void setRowCount(int rowCount) {        this.rowCount = rowCount;        this.setPageCount();    //当总数据受到影响时,总页数也会受到影响,需要同步修改    }    public int getPageSize() {        return pageSize;    }    public void setPageSize(int pageSize) {        this.pageSize = pageSize;        this.setPageCount();    //当展示行数受到影响时,总页数也会受到影响,需要同步修改    }    public int getPageNow() {        return pageNow;    }    public void setPageNow(int pageNow) {        this.pageNow = pageNow;    }    public int getPageCount() {        return pageCount;    }    public void setPageCount() {        this.pageCount = this.rowCount % this.pageSize == 0 ? this.rowCount                / this.pageSize : this.rowCount / this.pageSize + 1;    }    public List&lt;T&gt; getList() {        return list;    }    public void setList(List&lt;T&gt; list) {        this.list = list;    }}</code></pre><h4 id="2、编写实体类Users"><a href="#2、编写实体类Users" class="headerlink" title="2、编写实体类Users"></a>2、编写实体类Users</h4><pre><code>public class Users {    private int uid;    private String account;    private String password;    private String uname;    private String address;    public int getUid() {        return uid;    }    public void setUid(int uid) {        this.uid = uid;    }    public String getAccount() {        return account;    }    public void setAccount(String account) {        this.account = account;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public String getUname() {        return uname;    }    public void setUname(String uname) {        this.uname = uname;    }    public String getAddress() {        return address;    }    public void setAddress(String address) {        this.address = address;    }    @Override    public String toString() {        return &quot;Users [uid=&quot; + uid + &quot;, account=&quot; + account + &quot;, password=&quot; + password        + &quot;, uname=&quot; + uname + &quot;, address=&quot; + address + &quot;]&quot;;    }}</code></pre><h4 id="3、分页功能核心"><a href="#3、分页功能核心" class="headerlink" title="3、分页功能核心"></a>3、分页功能核心</h4><pre><code>    //Dao层分页核心,获得页面类对象    @Override    public PageBean&lt;Users&gt; getPage(int pageNow) {    //传入pageNow当前展示页        PageBean&lt;Users&gt; pb = new PageBean&lt;&gt;();    //实例化pageBean        pb.setPageNow(pageNow);    //pageBean设置当前页        String sql = &quot;select count(*) from users&quot;;    //查询总数据        //[Tips] int queryCount(String sql,Object...obj)方法：返回int        int allRow = queryCount(sql);    //记录下查询出来的总行数        pb.setRowCount(allRow);            //pageBean设置总数据        sql = &quot;select * from users limit ?,?&quot;;        //执行分页查询        //[Tips] List&lt;T&gt; query(String sql,Object...obj)方法：返回ArrayList        //记录下查询出来的要展示的分页数据        List&lt;T&gt; list = query(sql, (pageNow-1)*pb.getPageSize(),pb.getPageSize())        pb.setList(list);    //pageBean放入查询出来的ArrayList        return pb;    //前端页面根据返回的pageBean展示内容    }</code></pre><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>对分页的小记录，还没有用上分页条件查询，写的乱乱的。。。</p><p>后面会重新梳理一遍/(ㄒoㄒ)/~~</p>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
            <tag> Servlet </tag>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建一个Servlet程序</title>
      <link href="/2020/07/18/chuang-jian-yi-ge-servlet-cheng-xu/"/>
      <url>/2020/07/18/chuang-jian-yi-ge-servlet-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、创建方式"><a href="#一、创建方式" class="headerlink" title="一、创建方式"></a>一、创建方式</h3><p>创建servlet两种方式：</p><ul><li>实现 servlet 接口</li></ul><pre><code>package com.wenah;import java.io.IOException;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class FirstServlet implements Servlet{    @Override    public void destroy() {        //销毁方法    }    @Override    public ServletConfig getServletConfig() {        //用来返回初始化参数和 ServletContext        //ServletContext 接口提供有关 servlet 的环境信息        return null;    }    @Override    public String getServletInfo() {        //有关 servlet 的信息，如作者、版本、版权        return null;    }    @Override    public void init(ServletConfig arg0) throws ServletException {        //初始化方法,初始化时执行一次,以后调用不会再执行    }    @Override    public void service(ServletRequest arg0, ServletResponse arg1)        throws ServletException, IOException {        //主要函数,在这里处理请求,编写所需要的功能    }}</code></pre><ul><li>继承 HttpServlet 类（下面介绍）</li></ul><h3 id="二、Servlet的创建"><a href="#二、Servlet的创建" class="headerlink" title="二、Servlet的创建"></a>二、Servlet的创建</h3><p>继承 HttpServlet 类的创建过程：</p><ol><li>创建动态Web工程：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710103200979.png" alt="image-20200710103200979" style="zoom: 20%;" /></li><li>输入项目名，下一步：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710103701244.png" alt="image-20200710103701244" style="zoom:20%;" /></li><li>默认，下一步：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710104106343.png" alt="image-20200710104106343" style="zoom:15%;" /></li><li>勾上自动生成web.xml，完成项目创建：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710104225015.png" alt="image-20200710104225015" style="zoom:20%;" /></li><li>生成的项目文件目录：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710104505378.png" alt="image-20200710104505378" style="zoom:20%;" /></li><li>在 <strong>src文件夹</strong> 创建servlet：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710104636476.png" alt="image-20200710104636476" style="zoom:20%;" /></li><li>新建第一个Servlet：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710105029823.png" alt="image-20200710105029823" style="zoom:25%;" /></li><li>设置映射：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710105345733.png" alt="image-20200710105345733" style="zoom:20%;" /></li><li>选择需要的方法：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710105848006.png" alt="image-20200710105848006" style="zoom:25%;" /></li></ol><ul><li>生成测试类（自动生成@WebServlet注解）</li></ul><pre><code>package com.wenah.test;import java.io.IOException;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(&quot;/TestRequestServlet&quot;)public class TestRequestServlet extends HttpServlet {    private static final long serialVersionUID = 1L;//序列化相关    public void init(ServletConfig config) throws ServletException {}// 初始化方法    protected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException {        response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());    }    protected void doPost(HttpServletRequest request, HttpServletResponse response)    throws ServletException, IOException {        doGet(request, response);    }}</code></pre><ul><li>如果不使用注解，可以用 web.xml 设置映射</li></ul><pre><code>//web.xml设置：&lt;servlet&gt;    &lt;!-- servlet别名，和下面的对应 --&gt;    &lt;servlet-name&gt;TestRequestServlet&lt;/servlet-name&gt;    &lt;!-- servlet完整类名 --&gt;    &lt;servlet-class&gt;com.wenah.test.TestRequestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;!-- servlet别名，和上面的对应 --&gt;    &lt;servlet-name&gt;TestRequestServlet&lt;/servlet-name&gt;    &lt;!-- servlet映射地址(网页请求url) --&gt;    &lt;url-pattern&gt;/TestRequestServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;//等价于：@WebServlet(&quot;/TestRequestServlet&quot;)public class TestRequestServlet extends HttpServlet{    //类体......}</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet基础</title>
      <link href="/2020/07/18/servlet-ji-chu/"/>
      <url>/2020/07/18/servlet-ji-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Servlet概述"><a href="#一、Servlet概述" class="headerlink" title="一、Servlet概述"></a>一、Servlet概述</h3><h4 id="1-1、什么是Servlet？"><a href="#1-1、什么是Servlet？" class="headerlink" title="1.1、什么是Servlet？"></a>1.1、什么是Servlet？</h4><ul><li><p>Servlet（<strong>Server</strong> <strong>Applet</strong>）是 Java Servlet 的简称，称为<strong>小服务程序</strong>或<strong>服务连接器</strong>，用 Java 编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于<strong>交互式</strong>的浏览和生成数据，生成动态Web内容。</p></li><li><p>狭义的 Servlet 是指 Java 语言实现的<strong>一个接口</strong>，广义的Servlet是指<strong>任何实现了这个Servlet接口的类</strong>。</p><p>一般情况下，人们将Servlet理解为后者。</p></li><li><p>Servlet 的命名可以看出 sun 命名的特点，如 Applet 表示小应用程序；Scriptlet = Script + Applet，表示小脚本程序；同样 Servlet = Service + Applet，表示小服务程序。</p></li></ul><hr><h4 id="1-2、Servlet的生命周期"><a href="#1-2、Servlet的生命周期" class="headerlink" title="1.2、Servlet的生命周期"></a>1.2、Servlet的生命周期</h4><h5 id="一般情况下："><a href="#一般情况下：" class="headerlink" title="一般情况下："></a>一般情况下：</h5><ol><li><p><strong>客户端发送请求</strong> 到该 Servlet；</p></li><li><p>Web 容器<strong>解析请求</strong>；（比如Tomcat）</p></li><li><p>客户端的请求到达 Server，<strong>加载</strong> Servlet 类 <strong>到内存</strong>；</p><p>Server 创建一个<strong>请求对象</strong>处理客户端请求、创建一个<strong>响应对象</strong>响应客户端请求；</p></li><li><p><strong>实例化</strong> 并 <strong>调用</strong> <strong>init()</strong> <strong>方法</strong> 初始化该 Servlet；（init方法只会在初始化时<strong>执行一次</strong>，下次调用不会执行）</p></li><li><p>调用 <strong>service()</strong> ——根据请求方法不同调用doGet() 或者 doPost()来处理业务；</p><p>Server 激活 Servlet 的 service() 方法，传递请求和响应对象作为参数</p><p>此外还有doHead()、doPut()、doTrace()、doDelete()、doOptions()、destroy()；</p></li><li><p><strong>返回响应</strong>，输出响应信息；</p><p>service() 方法使用响应对象的方法，将响应传回Server，最终到达客户端。service()方法可能激活其它方法以处理请求，如 doGet() 或 doPost() 或程序员自己开发的新的方法。</p></li><li><p>调用 destory() 方法——关闭资源或销毁对象；（destory方法一般在<strong>Server关闭时调用</strong>）</p></li></ol><p><code>web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序。这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS或PWS都是这样的容器。一个服务器可以有多个容器。</code></p><p>对于更多的客户端请求，Server 创建新的请求和响应对象，仍然激活此 Servlet 的 service() 方法，将两个对象作为参数传递给它。如此重复以上的循环，但无需再次调用 init() 方法。一般 Servlet 只初始化一次(<strong>只有一个对象</strong>)。</p><hr><h5 id="Server-启动时强制装载和初始化特定的-Servlet"><a href="#Server-启动时强制装载和初始化特定的-Servlet" class="headerlink" title="Server 启动时强制装载和初始化特定的 Servlet"></a>Server 启动时强制装载和初始化特定的 Servlet</h5><p>加载和实例化 Servlet 一般是<strong>动态执行</strong>的。然而，Server 通常会提供一个管理的选项，用于在 Server 启动时强制装载和初始化特定的 Servlet。</p><ul><li>Servlet 的 init() 方法可配置为 Server 创建 Servlet 实例时调用，在 <code>web.xml</code> 中 <code>&lt;servlet&gt;</code> 标签下配置<code>&lt;load-on-startup&gt;</code> 标签，配置的值为整型，值越小 Servlet 的启动优先级越高。</li></ul><p>在servlet的配置当中，<code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code>的含义是：标记容器是否在<strong>启动的时候</strong>就加载这个servlet。</p><ul><li><p>当值为 <strong>0或者大于0</strong> 时，表示容器在应用<strong>启动时</strong>就加载这个 servlet；</p></li><li><p>当值为 <strong>负数时或者没有指定</strong> 时，则指示容器在该 servlet <strong>被请求时</strong> 才加载。</p></li><li><p><strong>正数的值越小</strong>，启动该 servlet 的<strong>优先级越高</strong>。</p></li></ul><hr><p><strong>比如 Tomcat7.0 的 web.xml 部分配置</strong>：(对于所有tomcat加载的web application都会应用，会和application本身指定的web.xml进行合并)</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;debug&lt;/param-name&gt;        &lt;param-value&gt;0&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;listings&lt;/param-name&gt;        &lt;param-value&gt;false&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- The mapping for the default servlet --&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><ol><li>该servlet的name为default,其对应的servlet-class类为org.apache.catalina.servlets.DefaultServlet。</li><li>对应的init-param标签中两个初始化参数:<ul><li>一个是 debug ,这个参数设置了 debug 的级别。</li><li>一个是 listings 参数，该参数的作用是当对应 URL 并没有对应一个资源时，是否要显示资源目录，该参数配置为了 false，也就是不显示。</li></ul></li><li>load-on-startup为1是说明当应用启动时就在加载该servlet。</li><li>DefaultServlet 的 servlet-mapping 配置的为：<strong>/</strong> ,处理所有的请求（请求优先级最低）<ul><li>一般只有defaultServlet会配置为/,如果自定义的Servlet也配置为/,那么将会覆盖defaultservlet的配置。</li><li>通过链接访问应用内的资源文件，例如.jpg,.html,.js这类的静态文件，就是 DefaultServlet 处理的请求。</li></ul></li></ol><hr><p>对于类似于 <strong>.jsp</strong> 的java动态服务页，我们可以直接通过一个URL例如 <strong>/index.jsp</strong> 来访问到该页面，这是因为在web.xml中有一个 <strong>JspServlet</strong> 来处理这类请求，即当用户请求的资源是一个jsp页面等时，访问的是JspServlet。</p><p>浏览器不能显示动态资源，JspServlet 将当前访问的 jsp 页面转换成静态的 html 页面，然后再响应给浏览器。</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;fork&lt;/param-name&gt;        &lt;param-value&gt;false&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;xpoweredBy&lt;/param-name&gt;        &lt;param-value&gt;false&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- The mappings for the JSP servlet --&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;    &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>JSP页的编译和执行Servlet， 是Tomcat支持JSP页面的机制。另外，这个servlet被映射的URL模式为”*.jsp”。 同时也支持一些初始化参数。它们都具有一些默认值。具体解释可以看 web.xml 中的注释。</p><hr><h5 id="关于-url-pattern-的匹配问题"><a href="#关于-url-pattern-的匹配问题" class="headerlink" title="关于 url-pattern 的匹配问题"></a>关于 url-pattern 的匹配问题</h5><ul><li><p>对于<code>&lt;url-pattern&gt;&lt;/url-pattern&gt;</code>一个Servlet可以配置多个 <strong>url-pattern</strong></p></li><li><p>优先级：完全匹配 &gt; 目录匹配 &gt; 扩展名匹配</p></li><li><p>在优先级相同的情况下，先访问范围更确定的url配置</p></li></ul><hr><h5 id="Servlet容器对Servlet的管理"><a href="#Servlet容器对Servlet的管理" class="headerlink" title="Servlet容器对Servlet的管理"></a>Servlet容器对Servlet的管理</h5><ul><li><p>Servlet 容器的主要功能是将<strong>请求转发</strong>到正确的 Servlet 进行处理，并在 JVM 处理完后将<strong>动态生成的结果返回</strong>到正确的位置。</p></li><li><p>在大多数情况下， Servlet 容器在单个 JVM 中运行，但是当容器需要多个 JVM 时，会有一些其它的解决方案。</p></li><li><p>Servlet 容器允许 JVM 在处理每个请求时使用 <strong>单独的</strong> <strong>Java</strong> <strong>线程</strong>，这是 Servlet 容器的一个主要优点。</p><ul><li>每个线程执行一个单一的 Servlet 实例的 service() 方法</li></ul></li><li><p>当 Server 不再需要 Servlet 时（一般当 Server 关闭时），Server 调用 Servlet 的 destroy() 方法。</p></li></ul><hr><h4 id="1-3、Servlet-线程安全问题"><a href="#1-3、Servlet-线程安全问题" class="headerlink" title="1.3、Servlet 线程安全问题"></a>1.3、Servlet 线程安全问题</h4><p>在 Web 应用程序中，一个 Servlet 在一个时刻可能被多个用户同时访问。这时 Web 容器将为每个用户创建一个线程来执行 Servlet。如果 Servlet 不涉及共享资源的问题，不必关心多线程问题。但如果 Servlet 需要共享资源，需要保证 Servlet 是线程安全的。</p><p><strong>线程安全的Servlet的一些方案：</strong></p><ul><li>用方法的<strong>局部变量</strong>保存请求中的<strong>专有数据</strong>。对方法中定义的局部变量，进入方法的每个线程都有自己的一份方法变量拷贝。任何线程都不会修改其他线程的局部变量。<ul><li>如果要在不同的请求之间<strong>共享数据</strong>，应该<strong>使用会话</strong>来共享这类数据。</li></ul></li><li>只用 Servlet 的<strong>成员变量</strong>来存放那些<strong>不会改变的数据</strong>。有些数据在 Servlet 生命周期中不发生任何变化，通常是在初始时确定的，这些数据可以使用成员变量保存，如数据库连接名称、其他资源的路径等。</li><li>对可能被请求<strong>修改</strong>的成员变量<strong>同步</strong>。有时数据成员变量或者环境属性可能被请求修改。当访问这些数据时应该对它们同步，以避免多个线程同时修改这些数据。</li><li>如果 Servlet <strong>访问外部资源</strong>，那么需要<strong>同步访问</strong>这些资源。例如，假设 Servlet 要从文件中读写数据。当一个线程读写一个文件时，其他线程也可能正在读写这个文件。文件访问本身不是线程安全的，所以必须编写同步访问这些资源的代码。</li></ul><p><strong>在编写线程安全的 Servlet 时，下面两种方法是不应该使用的：</strong></p><ol><li><p>在 Servlet API 中提供了一个 SingleThreadModel 接口，实现这个接口的 Servlet 在被多个客户请求时一个时刻只有一个线程运行。这个接口已被标记<em>不推荐使用</em>。</p></li><li><p>对 doGet() 或doPost() 方法同步。如果必须在 Servlet 中使用同步代码 <strong>synchronized(obj){}</strong>，应尽量在最小的代码块范围上进行同步。同步代码越小，Servlet 执行得才越好。</p></li></ol><hr><h4 id="1-4、简述DefaultServlet（默认Servlet）"><a href="#1-4、简述DefaultServlet（默认Servlet）" class="headerlink" title="1.4、简述DefaultServlet（默认Servlet）"></a>1.4、简述DefaultServlet（默认Servlet）</h4><ul><li><strong>JSP/Servlet架构的web项目</strong></li></ul><p>这类项目无需显示配置DefaultSerlvet。默认情况下，jsp后缀请求会交给JspServlet，静态资源请求图片等会交给DefaultServlet处理。</p><ul><li><strong>SSM中的 DispatcherServlet 配置</strong></li></ul><pre><code>&lt;!-- Spring MVC --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;description&gt;SpringMVC&lt;/description&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!-- 启动时加载 --&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>其中，由于早期的Spring MVC不能很好地处理静态资源，所以在web.xml中配置DispatcherServlet的请求映射，往往使用 *.do 、*.action、*.xhtml等方式。（在 Controller 中的 RequestMapping 的 Value 如果是字符串没有 .do 结尾，那么 Spring MVC 会默认的加上 .do）</p><ul><li>struts早期的1版本，以.do为后缀；同时spring的MVC也是以.do为后缀。</li><li>struts2沿用了webwork2的规则，以.action为后缀。</li></ul><p>当servlet-mapping配置为*.do这类带指定后缀的时候，静态资源文件依旧可以交给DefaultServlet处理。(*.do的DispatcherServlet不会拦截类似*.jsp,*.jpg的请求)</p><p>web.xml 中配置了<code>&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</code>后，会起到两个作用：<br>（1）是限制 url 的后缀名，只能为”.do”。<br>（2）就是在没有填写后缀时，默认在你配置的 Controller 的 RequestMapping 中添加”.do”的后缀。</p><p>这种处理一般般，不够优雅😄</p><hr><p>然而，当<strong>DispatcherServlet</strong>的mapping配置为： <strong>/</strong> 的时候：</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>则Spring MVC将捕获Web容器<strong>所有的请求</strong>，包括静态资源的请求，Spring MVC会将它们当成一个普通请求处理，因此找不到对应处理器将导致错误。</p><ul><li>这时候 <strong>DispatcherServlet</strong> 会 <strong>覆盖DefaultServlet</strong> 的配置(DispathcerServlet会<strong>更先匹配</strong>到)，那么对于.jpg,.png类似这种<strong>静态资源</strong>就得不到处理（之前是defaultServlet）会处理，所以这类资源就会得到404错误。所以我们需要有额外的配置来解决这个问题。</li></ul><p><strong>方法1.继续通过DefaultServlet来处理</strong>。在应用的web.xml中将常用的静态资源URL映射到defaultServlet上。</p><pre><code>&lt;!--增加匹配范围，使得优先级比DispathcerServlet的/高--&gt;&lt;!--通过defaultServlet来处理jpg--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--通过DefaultServlet来处理png--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.png&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--通过defaultServlet来处理.js文件--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--通过defaultServlet来处理.css文件--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><hr><p><strong>方法2.采用&lt;mvc:default-servlet-handler /&gt;</strong></p><pre><code>&lt;mvc:default-servlet-handler /&gt;</code></pre><p>在 <strong>springMVC-servlet.xml</strong> 中配置<code>&lt;mvc:default-servlet-handler /&gt;</code>后，会在Spring MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，它会<strong>像一个检查员</strong>，对进入DispatcherServlet的URL进行<strong>筛查</strong>，如果发现是<strong>静态资源的请求</strong>，就将该请求<strong>转交给</strong>Web应用服务器<strong>默认的Servlet（DefaultServlet）</strong>处理，如果不是静态资源的请求，才由DispatcherServlet继续处理。</p><ul><li>一般Web应用服务器默认的Servlet名称是”default”，因此DefaultServletHttpRequestHandler可以找到它。如果使用的Web应用服务器的默认Servlet名称<strong>不是”default”</strong>，则需要通过default-servlet-name属性显示指定：</li></ul><p><code>&lt;mvc:default-servlet-handler default-servlet-name=&quot;所使用的Web服务器默认使用的Servlet名称&quot; /&gt;</code></p><hr><p><strong>方法3.采用&lt;mvc:resources /&gt;</strong></p><p><code>&lt;mvc:default-servlet-handler /&gt;</code>将静态资源的处理经由Spring MVC框架交回Web应用服务器处理。</p><p>而<code>&lt;mvc:resources /&gt;</code>更进一步，由Spring MVC框架自己处理静态资源，并添加一些有用的附加值功能。</p><ul><li><p>首先，&lt;mvc:resources /&gt;允许静态资源放在任何地方</p><ul><li>如WEB-INF目录下、类路径下等，甚至可以将JavaScript等静态文件打到JAR包中。</li><li>通过location属性指定静态资源的位置，由于location属性是Resources类型，因此可以使用诸如”classpath:”等的资源前缀指定资源位置。</li><li>传统Web容器的静态资源只能放在Web容器的根路径下，&lt;mvc:resources /&gt;完全打破了这个限制。</li></ul></li><li><p>其次，&lt;mvc:resources /&gt;依据当前著名的Page Speed、YSlow等浏览器优化原则对静态资源提供优化。</p><ul><li>可以通过cacheSeconds属性指定静态资源在浏览器端的缓存时间，一般可将该时间设置为一年，以充分利用浏览器端的缓存。</li><li>在输出静态资源时，会根据配置设置好响应报文头的Expires 和 Cache-Control值。</li><li>在接收到静态资源的获取请求时，会检查请求头的Last-Modified值，如果静态资源没有发生变化，则直接返回303相应状态码，提示客户端使用浏览器缓存的数据，而非将静态资源的内容输出到客户端，以充分节省带宽，提高程序性能。</li></ul></li></ul><p><strong>在springMVC-servlet中添加如下配置：</strong></p><pre><code>&lt;mvc:resources location=&quot;/,classpath:/META-INF/publicResources/&quot; mapping=&quot;/resources/**&quot;/&gt;</code></pre><p>以上配置将 <strong>Web根路径&quot;/&quot;</strong> 及 <strong>类路径下</strong> <strong>/META-INF/publicResources/</strong> 的目录 <strong>映射为/resources路径</strong>。</p><ul><li><p>假设Web根路径下拥有images、js这两个资源目录,在images下面有bg.gif图片，在js下面有test.js文件，则可以通过 /resources/images/bg.gif 和 /resources/js/test.js 访问这二个静态资源。</p></li><li><p>假设WebContent还拥有images/bg1.gif 及 js/test1.js，则也可以在网页中通过 /resources/images/bg1.gif 及 /resources/js/test1.js 进行引用。</p></li></ul><p><strong>也可以配置指定直接放行，将静态资源的映射进行放行：</strong></p><pre><code>&lt;!-- 放行静态资源 --&gt;&lt;!-- 放行js文件 --&gt;&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;&lt;!-- 放行css文件 --&gt;&lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;&lt;!--放行img类的资源文件--&gt;&lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt;</code></pre><hr><h3 id="二、继承HttpServlet类的方法"><a href="#二、继承HttpServlet类的方法" class="headerlink" title="二、继承HttpServlet类的方法"></a>二、继承HttpServlet类的方法</h3><p>HTTPServlet 使用一个 HTML 表单来发送和接收数据。该类是用专门的方法来处理 HTML <a href="https://baike.baidu.com/item/表单" target="_blank" rel="noopener">表单</a>的 GenericServlet 的一个子类。 HTML 表单是由 <code>&lt;form&gt;&lt;/form&gt;</code> 标记定义的。 HttpServlet 类包含 init()、destroy()、service() 等方法。其中 init() 和 destroy() 方法是继承的。</p><ul><li><strong>javax.servlet</strong> 软件包中的相关类为 <strong>ServletResponse和ServletRequest</strong>。</li><li><strong>javax.servlet.http</strong> 软件包中的相关类为 <strong>HttpServletRequest和HttpServletResponse</strong>。<ul><li>Servlet 通过这些对象与服务器通信并最终与客户端通信。</li></ul></li><li>Servlet 能通过调用”请求”对象的方法获知<strong>客户端环境</strong>，<strong>服务器环境</strong>的信息和所有由<strong>客户机发送的信息</strong>。Servlet 可以调用“响应”对象的方法<strong>发送响应</strong>，该响应是准备发回客户端的。</li></ul><h4 id="1-init-方法"><a href="#1-init-方法" class="headerlink" title="(1) init() 方法"></a>(1) init() 方法</h4><ul><li><p>在 Servlet 的生命期中，仅执行一次 init() 方法。它是在服务器装入 Servlet 时执行的。 </p></li><li><p>可以手动配置服务器，以在启动服务器或客户机首次访问 Servlet 时装入 Servlet。 无论有多少客户机访问 Servlet，都不会重复执行 init() 。</p></li><li><p>缺省 init() 方法通常是符合要求的，但也可以用定制 init() 方法来覆盖它，典型的是管理服务器端资源。 </p><ul><li>例如，可能编写一个定制 init() 来只用于一次装入 GIF 图像，改进 Servlet 返回 GIF 图像和含有多个客户机请求的性能。</li><li>另一个示例是初始化数据库连接。</li></ul></li><li><p>缺省的 init() 方法设置了 Servlet 的初始化参数，并用它的 ServletConfig 对象参数来启动配置， 因此所有覆盖 init() 方法的 Servlet 应调用 super.init() 以确保仍然执行这些任务。</p></li><li><p>在调用 service() 方法之前，应确保已完成了 init() 方法。</p></li></ul><h4 id="2-service-方法"><a href="#2-service-方法" class="headerlink" title="(2) service() 方法"></a>(2) service() 方法</h4><ul><li>service() 方法是 Servlet 的核心。每当一个客户请求一个HttpServlet 对象，该对象的service() 方法就要被调用，而且传递给这个方法一个”请求”(ServletRequest)对象和一个”响应”(ServletResponse)对象作为参数。</li><li>在 HttpServlet 中已存在 service() 方法，调用与 HTTP 请求的方法相应的 do 功能。<ul><li>例如， 如果 HTTP 请求方法为 GET，则调用 doGet() 。</li></ul></li><li>HttpServlet.service() 方法会检查请求方法是否调用了适当的处理方法，不必要覆盖 service() 方法。只需覆盖相应的 do 方法就可以了（一般都覆盖：doGet()方法、doPost()方法）。</li></ul><pre><code>//httpservlet的service()方法：protected void service(HttpServletRequest req, HttpServletResponse resp)    throws ServletException, IOException{    String method = req.getMethod();//获取请求方法    if(method.equals(&quot;GET&quot;)){        long lastModified = getLastModified(req);        if(lastModified == -1L){            doGet(req, resp);        }else{            long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);            if(ifModifiedSince &lt; (lastModified / 1000L) * 1000L){                maybeSetLastModified(resp, lastModified);                doGet(req, resp);            }else{                resp.setStatus(304);            }        }    }else if(method.equals(&quot;HEAD&quot;)){        long lastModified = getLastModified(req);        maybeSetLastModified(resp, lastModified);        doHead(req, resp);    }else if(method.equals(&quot;POST&quot;))        doPost(req, resp);    else if(method.equals(&quot;PUT&quot;))        doPut(req, resp);    else if(method.equals(&quot;DELETE&quot;))        doDelete(req, resp);    else if(method.equals(&quot;OPTIONS&quot;))        doOptions(req, resp);    else if(method.equals(&quot;TRACE&quot;)){        doTrace(req, resp);    }else{        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);        Object errArgs[] = new Object[1];        errArgs[0] = method;        errMsg = MessageFormat.format(errMsg, errArgs);        resp.sendError(501, errMsg);    }}</code></pre><p><strong>Servlet的响应可以是下列几种类型：</strong></p><p><code>response.getWriter() //输出页面</code></p><p><code>response.getOutputStream() //输出二进制流文件</code></p><p><code>request.getRequestDispatcher(&quot;target.jsp&quot;).forward(request, response) //转发</code></p><p><code>response.sendRedirect(&quot;ajax.jsp&quot;) //重定向</code></p><ul><li>关于重定向：等于客户端重新发送一个请求（新的线程，新生成的请求和响应）</li><li>关于转发：等于服务器内部跳转到别的servlet（同一线程，同一个请求和响应）</li></ul><p>一个servlet请求只能有一个响应，任何多个响应的代码都是错误的，都会出现<code>IllegalStateException</code>。也就是说，多个响应的场景是非法的。</p><h4 id="3-doGet-方法"><a href="#3-doGet-方法" class="headerlink" title="(3) doGet() 方法"></a>(3) doGet() 方法</h4><ul><li>当一个客户通过 HTML 表单发出一个 HTTP GET 请求或直接请求一个 URL 时，doGet() 方法被调用。</li><li>与 GET 请求相关的参数添加到 URL 的后面，并与这个请求一起发送。</li><li>当不会修改服务器端的数据时，应该使用 doGet() 方法。</li></ul><h4 id="4-doPost-方法"><a href="#4-doPost-方法" class="headerlink" title="(4) doPost() 方法"></a>(4) doPost() 方法</h4><ul><li>当一个客户通过 HTML 表单发出一个 HTTP POST 请求时，doPost() 方法被调用。</li><li>与 POST 请求相关的参数作为一个单独的 HTTP 请求从浏览器发送到服务器。</li><li>当需要修改服务器端的数据时，应该使用 doPost() 方法。</li></ul><h4 id="5-destroy-方法"><a href="#5-destroy-方法" class="headerlink" title="(5) destroy() 方法"></a>(5) destroy() 方法</h4><ul><li><p>destroy() 方法仅执行一次，即在服务器停止且卸装 Servlet 时执行该方法。</p><ul><li>例如：将 Servlet 作为服务器进程的一部分来关闭。</li></ul></li><li><p>缺省的 destroy() 方法通常是符合要求的，但也可以覆盖它。</p><ul><li>例如：管理服务器端资源，如果 Servlet 在运行时会累计统计数据，则可以编写一个 destroy() 方法，该方法用于在未装入 Servlet 时将统计数字保存在文件中。</li><li>另一个示例是关闭数据库连接。</li></ul></li><li><p>当服务器卸装 Servlet 时，将在所有 service() 方法调用完成后，或在指定的时间间隔过后调用 destroy() 方法。一个 Servlet 在运行 service() 方法时可能会产生其它的线程，因此请确认在调用 destroy() 方法时，这些线程已终止或完成。</p></li></ul><h4 id="6-getServletConfig-方法"><a href="#6-getServletConfig-方法" class="headerlink" title="(6) getServletConfig() 方法"></a>(6) getServletConfig() 方法</h4><p>getServletConfig() 方法返回一个 ServletConfig 对象，该对象用来返回初始化参数和 ServletContext。ServletContext 接口提供有关 servlet 的环境信息。</p><h4 id="7-getServletInfo-方法"><a href="#7-getServletInfo-方法" class="headerlink" title="(7) getServletInfo() 方法"></a>(7) getServletInfo() 方法</h4><p>getServletInfo() 方法是一个可选的方法，它提供有关 servlet 的信息，如作者、版本、版权。</p><hr><h3 id="三、HttpRequest方法"><a href="#三、HttpRequest方法" class="headerlink" title="三、HttpRequest方法"></a>三、HttpRequest方法</h3><ul><li><strong>setCharacterEncoding(编码格式)</strong></li></ul><p><code>request.setCharacterEncoding(&quot;utf-8&quot;); //设置请求编码格式</code></p><p><code>response.setCharacterEncoding(&quot;utf-8&quot;) //设置响应编码格式;</code></p><ul><li><strong>getParameter(String</strong> <strong>key)</strong>  <strong>返回一个字符串</strong><ul><li>获得name和key一样的表单空间的数据，如果name有重复，则返回的是第一个找到的name属性的数据</li></ul></li></ul><p><code>通过getParameter获取到请求链中的name属性对应第一个value值</code>  </p><p><code>String uname = request.getParameter(&quot;name&quot;);  System.*out*.println(&quot;用户名为：&quot;+uname);</code> </p><ul><li><strong>getParameterValues(String</strong> <strong>key)</strong>  <strong>返回一个字符串的数组</strong><ul><li>获得name和key一样的表单控件的数据，但是相同name控件会有多个（返回所有的name数据）；</li></ul></li></ul><pre><code>//通过getParameterValues获取到请求链中的name属性对应的一组value值    String[] hobby =  request.getParameterValues(&quot;hobby&quot;);System.out.print(&quot;爱好为：&quot;);for(String str:hobby){    System.out.print(str+&quot;,&quot;);}System.out.println();</code></pre><ul><li><strong>getParameterMap()</strong>  <strong>返回一个包含所有参数的map</strong><ul><li>key-String[]模式，即key是表单控件的name，同时，为防止有重复的name的控件存在，每个name对应一个字符串数据 </li></ul></li></ul><pre><code>//通过getParameterMap获取到整个form表单数据Map&lt;String, String[]&gt; form = request.getParameterMap();//通过key获取到整个表单的name属性Set&lt;String&gt; names = form.keySet();for(String str:names){    System.out.print(str+&quot;:&quot;);    String[] values = form.get(str);    String value = &quot;&quot;;    for(String val:values){        value += val+&quot;,&quot;;    }        System.out.println( value.substring(0,value.length()-1) );}  </code></pre><ul><li><p>setcharacterEncoding(): 设置请求通道编码格式</p></li><li><p>getRemoteAddr()：返回客户端的IP地址</p></li><li><p>getContentType()：获得请求正文的MIME类型</p></li><li><p>getContextPath()：返回客户端所请求访问的Web应用的URL入口</p></li><li><p>getMethod()：返回Http请求方式</p></li><li><p>getRequestDispatcher() :转发到指定地址并使用forward跳转</p></li></ul><h3 id="四、HttpServletResponse方法"><a href="#四、HttpServletResponse方法" class="headerlink" title="四、HttpServletResponse方法"></a>四、HttpServletResponse方法</h3><ul><li><p>setCharacterEncoding(): 设置响应通道编码格式</p></li><li><p>setContentType(String type)：设置响应正文的MIME类型</p></li><li><p>getCharacterEncoding()：返回响应正文的字符编码</p></li><li><p>getContentType()：返回响应正文的MIME类型。</p></li><li><p>sendRedirect() 用于响应重定向</p></li></ul><p>在用户浏览器工作中，sendRedirect()可以带参数传递，比如    response.sendRedirect(“welcome?acount=”+account+”&amp;password=”+password)，传递    至下一个页面，同时它可以重新指向另一个页面</p><p>注：1.welcome代表你要重定向的那个Servlet的url</p><p>​        2.Servlet url名和变量之间有？连接</p><p>​        3.如果要传递两个或以上参数，参数之间用&amp;连接</p><hr><h3 id="五、request-getRequestURL-和request-getRequestURI-的区别"><a href="#五、request-getRequestURL-和request-getRequestURI-的区别" class="headerlink" title="五、request.getRequestURL()和request.getRequestURI()的区别"></a>五、request.getRequestURL()和request.getRequestURI()的区别</h3><ul><li><p>request.getRequestURL() 返回 <strong>全路径</strong></p><ul><li>如：<a href="http://localhost:8080/myServlet/page/index.jsp" target="_blank" rel="noopener">http://localhost:8080/myServlet/page/index.jsp</a></li></ul></li><li><p>request.getRequestURI() 返回 <strong>除去host（域名或者ip）部分的路径</strong></p><ul><li>如：/myServlet/page/index.jsp</li></ul></li><li><p>request.getContextPath() 返回 <strong>工程名部分</strong>，如果工程映射为/，此处返回则为空</p><ul><li>如：/myServlet</li></ul></li><li><p>request.getServletPath() 返回 <strong>除去host和工程名部分的路径</strong></p><ul><li>如：/page/index.jsp</li></ul></li></ul><p><strong>注：myServlet为工程名、page为WebContext下的目录名</strong></p><hr><h3 id="六、getInitParameter方法-从web-xml中获取参数"><a href="#六、getInitParameter方法-从web-xml中获取参数" class="headerlink" title="六、getInitParameter方法(从web.xml中获取参数)"></a>六、getInitParameter方法(从web.xml中获取参数)</h3><p>在 <strong>ServletConfig</strong> 和 <strong>ServletContext</strong> 都有 getInitParameter 方法， </p><p>这两个方法的都能从web.xml中获取参数，但是是有区别的。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;web-app id=&quot;WebApp_ID&quot; version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;      &lt;context-param&gt;        &lt;param-name&gt;webParam&lt;/param-name&gt;        &lt;param-value&gt;bigbigbig&lt;/param-value&gt;      &lt;/context-param&gt;      &lt;servlet&gt;          &lt;servlet-name&gt;test&lt;/servlet-name&gt;          &lt;servlet-class&gt;com.wenah.Test&lt;/servlet-class&gt;          &lt;init-param&gt;            &lt;param-name&gt;servletParam&lt;/param-name&gt;            &lt;param-value&gt;smallsmallsmall&lt;/param-value&gt;          &lt;/init-param&gt;      &lt;/servlet&gt;      &lt;servlet-mapping&gt;          &lt;servlet-name&gt;test&lt;/servlet-name&gt;          &lt;url-pattern&gt;/testParam&lt;/url-pattern&gt;      &lt;/servlet-mapping&gt;  &lt;/web-app&gt;  </code></pre><p>测试类：</p><pre><code>@WebServlet(&quot;/testParam&quot;)public class Test extends HttpServlet {    public void doGet(HttpServletRequest request, HttpServletResponse response)              throws ServletException, IOException {        //独属于Test这个Servlet的参数:        String sParam = this.getInitParameter(&quot;servletParam&quot;);        //web范围的参数:        String wParam = this.getServletContext().getInitParameter(&quot;webParam&quot;);          String ret = &quot;{Test}sParam:&quot;+sParam+&quot;&lt;br/&gt;{Test}wParam:&quot;+wParam;        resp.getWriter().write(ret);    }  }  </code></pre><p>输出结果：</p><p>{Test}sParam:smallsmallsmall</p><p>{Test}wParam:bigbigbig</p><hr><h3 id="七、Filter过滤器"><a href="#七、Filter过滤器" class="headerlink" title="七、Filter过滤器"></a>七、Filter过滤器</h3><ul><li>Filter过滤器是servlet和jsp的核心技术</li><li>可以统一的去控制资源，统一处理问题，对于<strong>权限的控制</strong>，可以大大的提高开发的效率，高复用部分代码。</li></ul><h4 id="5-1、实现的接口为servlet-filter接口"><a href="#5-1、实现的接口为servlet-filter接口" class="headerlink" title="5.1、实现的接口为servlet.filter接口"></a>5.1、实现的接口为servlet.filter接口</h4><ol><li>当客户端发送请求后，servlet容器会调用filter过滤器</li><li>如果请求在filter中<strong>通过</strong>，则会将请求转发给servlet</li><li>如果请求在filer中<strong>不通过</strong>，则进行指定跳转</li></ol><p><strong>Filter中需要实现的方法：</strong></p><ul><li>Init方法</li><li>doFilter方法</li><li>destroy 方法</li></ul><hr><h4 id="5-2、创建字符编码过滤器（解决中文乱码问题）"><a href="#5-2、创建字符编码过滤器（解决中文乱码问题）" class="headerlink" title="5.2、创建字符编码过滤器（解决中文乱码问题）"></a>5.2、创建字符编码过滤器（解决中文乱码问题）</h4><p>需要实现filter接口：</p><pre><code>public class EncodingFilter implements Filter {    //定义一个变量，用于接收配置文件中的初始属性    String encoding = &quot;&quot;;    @Override    public void destroy() {        // TODO Auto-generated method stub    }    @Override    public void doFilter(ServletRequest arg0, ServletResponse arg1,            FilterChain filterChain) throws IOException, ServletException {        //因为filter中使用的请求与响应都不携带Http协议，需要先将请求与响应强转为http协议的请求与响应        HttpServletRequest request = (HttpServletRequest) arg0;        HttpServletResponse response = (HttpServletResponse) arg1;        //当filter中统一设置编码格式后，其他的类都不需要设置编码格式        request.setCharacterEncoding(encoding);        response.setCharacterEncoding(encoding);        response.setContentType(&quot;text/html;charset=utf-8&quot;);        //让过滤器将执行后的请求与响应再次回到请求链中        filterChain.doFilter(request, response);    }    @Override    public void init(FilterConfig config) throws ServletException {        //getInitParameter()从web.xml中获取对应的参数        encoding = config.getInitParameter(&quot;encoding&quot;);    }}</code></pre><p><strong>配置web.xml文件</strong>，使指定请求进入到filter过滤器中</p><pre><code>&lt;!-- 设置一对filter映射关系 --&gt;&lt;filter&gt;    &lt;filter-name&gt;encod&lt;/filter-name&gt;    &lt;filter-class&gt;com.entor.filter.EncodingFilter&lt;/filter-class&gt;    &lt;!-- 为过滤器设置一个初始属性，在过滤器中的init方法获取 --&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encod&lt;/filter-name&gt;    &lt;!-- /*表示所有的请求都会进入过滤器 --&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><hr><h4 id="5-3、登录权限控制"><a href="#5-3、登录权限控制" class="headerlink" title="5.3、登录权限控制"></a>5.3、登录权限控制</h4><pre><code>public class UsersFilter implements Filter {    //定义可放行的请求    String[] urls = {&quot;/login&quot;,&quot;/loginServlet&quot;};    @Override    public void destroy() {}    @Override    public void doFilter(ServletRequest arg0, ServletResponse arg1,            FilterChain chain) throws IOException, ServletException {        HttpServletRequest request = (HttpServletRequest) arg0;        HttpServletResponse response = (HttpServletResponse) arg1;        boolean flag = false;        //获取到请求的相对路径        String path = request.getRequestURI();        for(String url:urls){    //遍历验证可放行的请求            if(path.indexOf(url)!=-1){                flag = true;                break;            }        }        if(flag){            chain.doFilter(request, response); //可放行的请求,执行放行操作        }else{            //判断session是否为空，session都为空一定是非登录状态            //getSession(false)：false表示获取对象而非创建session对象            if(request.getSession(false)!=null){                //从session中获取到user对象                Users user = (Users) request.getSession(false).getAttribute(&quot;user&quot;);                if(user!=null){                    //如果都验证成功，回到请求链                    chain.doFilter(request, response);    //已登陆用户,执行放行操作                }            }            //如果不成功则重定向到login界面(也可自定义失败页面)            response.sendRedirect(&quot;login&quot;);        }    }    @Override    public void init(FilterConfig arg0) throws ServletException {        // TODO Auto-generated method stub    }}</code></pre><p>配置权限控制过滤器的web.xml</p><pre><code>&lt;!-- 设置一对filter映射关系 --&gt;&lt;filter&gt;    &lt;filter-name&gt;userFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.entor.filter.UsersFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;userFilter&lt;/filter-name&gt;    &lt;!-- /*表示所有的请求都会进入过滤器 --&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>越写越多了，w(ﾟДﾟ)w</p><hr><blockquote><p><a href="https://baike.baidu.com/item/servlet" target="_blank" rel="noopener">百度百科|Servlet</a></p><p><a href="https://blog.csdn.net/qq_30920821/java/article/details/78328608" target="_blank" rel="noopener">Web容器中DefaultServlet详解</a></p><p><a href="https://blog.csdn.net/javadxz/article/details/6400448" target="_blank" rel="noopener">servlet doPost() doHead() doGet()等方法被执行的由来</a></p><p><a href="https://www.cnblogs.com/dflmg/p/6393416.html" target="_blank" rel="noopener">【Spring框架】<a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a>的作用</a></p><p><a href="https://blog.csdn.net/gavid0124/java/article/details/45390999" target="_blank" rel="noopener">request.getRequestURL()和request.getRequestURI()的区别</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
            <tag> 基础 </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro系统安全框架</title>
      <link href="/2020/07/16/shiro-ji-chu/"/>
      <url>/2020/07/16/shiro-ji-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Shiro介绍"><a href="#一、Shiro介绍" class="headerlink" title="一、Shiro介绍"></a>一、Shiro介绍</h3><h4 id="1-1、-Shiro是什么？"><a href="#1-1、-Shiro是什么？" class="headerlink" title="1.1、 Shiro是什么？"></a>1.1、 Shiro是什么？</h4><ul><li>Apache Shiro 是 Java 的一个安全框架</li><li>为应用系统设一道屏障，防止有人恶意入侵</li><li>维护系统登陆与权限控制</li><li>轻量级框架（JaveSE环境、JavaEE环境都可用）</li></ul><hr><h4 id="1-2、-Shiro主要用在哪里？"><a href="#1-2、-Shiro主要用在哪里？" class="headerlink" title="1.2、 Shiro主要用在哪里？"></a>1.2、 Shiro主要用在哪里？</h4><ul><li><p>处理系统用户的身份认证（验证一个人的身份，是否同一人）</p><ul><li>传统的身份验证：如用户登录，输入用户名 + 密码，再判断用户名与密码的信息。（简单、不够安全）</li><li>Shiro：有一整套身份认证策略，还有其他辅助功能。提供了其他的安全保障、嗨提供了密码加密处理功能（MD5）</li></ul></li><li><p>权限的授权</p></li><li><p>会话管理方面的事务</p></li></ul><hr><h4 id="1-3、-Shiro基本功能"><a href="#1-3、-Shiro基本功能" class="headerlink" title="1.3、 Shiro基本功能"></a>1.3、 Shiro基本功能</h4><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/image-20200716101830536.png" style="zoom: 33%;" /><ol><li>Authentication<ul><li>身份认证/登陆。</li><li>验证用户是不是拥有相应的身份。</li></ul></li><li>Authorization<ul><li>授权（权限认证）。</li><li>验证某个已认证的用户是否拥有某个权限。<ul><li>粗粒度：按觉得划分，验证某个用户是否拥有某个角色（能操作哪些内容）。</li><li>细粒度：按资源划分，验证某个用户对<strong>某个资源</strong>是否拥有<strong>权限</strong>。</li></ul></li></ul></li><li>Session Manager<ul><li>用户登陆后，退出之前，它的所有信息都在会话中。</li><li>会话可以在普通 <strong>JavaSE</strong> 环境，也可以是 <strong>Web</strong> 环境。</li></ul></li><li>Cryptography<ul><li>加密，主要是指保护数据的安全性。</li><li>比如：密码<strong>加密</strong>后存储到数据库，而不是<strong>明文存储</strong>。<ul><li>明文保存有重大隐患（泄露、非法入侵者、非法操作的工作人员等可直接获取）</li></ul></li></ul></li></ol><hr><h3 id="二、Shiro的执行"><a href="#二、Shiro的执行" class="headerlink" title="二、Shiro的执行"></a>二、Shiro的执行</h3><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/image-20200716133326220.png" style="zoom:50%;" /><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/image-20200716141233462.png" style="zoom: 50%;" /><ul><li>应用启动后</li><li>当前用户进入（比如调用 login() 方法）</li><li>首先会经过 <strong>Shiro</strong> <strong>SecurityManager</strong> 安全管理器</li><li>通过 <strong>Realm</strong> 访问安全数据<ul><li>比如登陆：获取数据库的用户名与密码，提供给验证器验证。</li><li>比如用户某个操作的权限管理：获取用户权限数据，提供验证器验证。</li></ul></li></ul><hr><h3 id="三、常见-API-对象"><a href="#三、常见-API-对象" class="headerlink" title="三、常见 API 对象"></a>三、常见 API 对象</h3><h4 id="3-1、Subject"><a href="#3-1、Subject" class="headerlink" title="3.1、Subject"></a>3.1、Subject</h4><ul><li><p>概念描述</p><ul><li><p>主体，代表了当前“用户”，这个用户不一定是一个具体的人。</p></li><li><p>与当前应用交互的任何东西都是Subject，如：网络爬虫、机器人等。</p></li></ul></li><li><p>与 Subject 的所有交互都会委托给 SecurityManager 处理</p><ul><li>Subject调用方法执行，底层代码实现交给 SecurityManager 。</li></ul></li></ul><h4 id="3-2、SecurityManager"><a href="#3-2、SecurityManager" class="headerlink" title="3.2、SecurityManager"></a>3.2、SecurityManager</h4><ul><li>安全管理器，即所有与安全有关的操作都会与 SecurityManager  交互。</li><li>管理着所有的 Subject 主体。</li><li>Shiro 的核心，负责与后面介绍的其他组件进行交互，可把它看作 ”控制器“。</li></ul><h4 id="3-3、Realm（翻译：n-领域-场所-王国）"><a href="#3-3、Realm（翻译：n-领域-场所-王国）" class="headerlink" title="3.3、Realm（翻译：n.领域;场所;王国）"></a>3.3、Realm（翻译：n.领域;场所;王国）</h4><ul><li>域，Shiro 从 Realm 获取 “安全数据” （如：用户、角色、权限）</li><li>即是 SecurityManager 要验证用户身份时，它需要冲 Realm 获取相应的用户进行<strong>比较</strong>，以确定用户身份是否合法。也需要从 Realm 得到用户相应的 <strong>角色/权限</strong> 进行验证用户是否能进行操作。</li><li>可以把 Realm 看成 DataSource，即<strong>安全数据源</strong>。</li></ul><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/image-20200716141657352.png" style="zoom:50%;" /><hr><h3 id="四、Shiro的内部结构"><a href="#四、Shiro的内部结构" class="headerlink" title="四、Shiro的内部结构"></a>四、Shiro的内部结构</h3><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/ShiroInner.png" style="zoom: 80%;" /><ul><li>Realm可插拔，各个Realm有对应的数据库。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
            <tag> Shiro </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基础</title>
      <link href="/2020/07/10/http-bi-ji/"/>
      <url>/2020/07/10/http-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="1、HTTP简介"><a href="#1、HTTP简介" class="headerlink" title="1、HTTP简介"></a>1、HTTP简介</h3><h4 id="1-1、-HTTP是什么？"><a href="#1-1、-HTTP是什么？" class="headerlink" title="1.1、 HTTP是什么？"></a>1.1、 HTTP是什么？</h4><ol><li><p>HTTP协议是 <strong>Hyper Text Transfer Protocol</strong>（超文本传输协议）的缩写。</p></li><li><p>是用于万维网（WWW:World Wide Web）传输超文本的传送协议，规定WWW服务器与浏览器之间信息传递规范。（HTTP协议 <strong>永远都是</strong> 客户端发起请求，服务器回送响应）</p></li><li><p>HTTP基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等），默认端口号为80。</p></li></ol><h4 id="1-2、-三个特性"><a href="#1-2、-三个特性" class="headerlink" title="1.2、 三个特性"></a>1.2、 三个特性</h4><ul><li>HTTP是无连接的：每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。（连接是有限的，并且及时地释放连接提高服务器的执行效率）</li><li>HTTP是媒体独立的：只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。（MIME-type：如Content-Type: text/HTML）</li><li>HTTP是无状态：无状态协议，即服务器不保留与客户交易时的任何状态。同一个客户端的这次请求和上次请求是没有对应关系。这就大大减轻了服务器记忆负担，从而保持较快的响应速度。</li></ul><h4 id="1-3、-MIME-type-是什么？"><a href="#1-3、-MIME-type-是什么？" class="headerlink" title="1.3、 MIME-type 是什么？"></a>1.3、 MIME-type 是什么？</h4><ul><li><p>MIME (<strong>M</strong>ultipurpose <strong>I</strong>nternet <strong>M</strong>ail <strong>E</strong>xtensions) —— 描述消息内容类型的因特网标准。</p></li><li><p>也就是资源的媒体类型，通常只有一些在互联网上获得广泛应用的格式才会获得一个 MIME Type。</p></li><li><p>如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。</p></li></ul><p><strong>每个MIME类型由两部分组成：</strong></p><ol><li><p>前面是数据的大类别，例如声音audio、图象image等</p></li><li><p>后面定义具体的种类。</p></li></ol><p><strong>常见的MIME类型：</strong></p><ul><li>超文本标记语言文本 .htm、.html   ——  <strong>text/html</strong> </li><li>普通文本 .txt   ——  <strong>text/plain</strong></li><li>RTF文本 .rtf   ——  <strong>application/rtf</strong></li><li>GIF图形 .gif   ——  <strong>image/gif</strong> </li><li>JPEG图形 .ipeg、.jpg   ——  <strong>image/jpeg</strong></li><li>au声音文件 .au   ——  <strong>audio/basic</strong></li><li>MIDI音乐文件 mid、.midi   ——  <strong>audio/midi</strong></li><li>RealAudio音乐文件 .ra、.ram   ——  <strong>audio/x-pn-realaudio</strong> </li><li>MPEG文件 .mpg、.mpeg   ——  <strong>video/mpeg</strong> </li><li>AVI文件 .avi   ——  <strong>video/x-msvideo</strong> </li><li>GZIP文件 .gz   ——  <strong>application/x-gzip</strong> </li><li>TAR文件 .tar   ——  <strong>application/x-tar</strong> </li></ul><h4 id="1-4、-HTTP的工作原理"><a href="#1-4、-HTTP的工作原理" class="headerlink" title="1.4、 HTTP的工作原理"></a>1.4、 HTTP的工作原理</h4><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><p>（1）客户与服务器建立连接（开始一个链接，如点击 &lt;a href=&quot;<a href="https://coderuan.cn&quot;" target="_blank" rel="noopener">https://coderuan.cn&quot;</a> /&gt;wenah阮&lt;/a&gt; 标签）</p><p>（2）客户向服务器提出请求（格式为：请求行、请求头部、空行和请求数据四个部分组成）</p><p>（3）服务器接受请求，并根据请求返回相应的应答（分别是：状态行、消息报头、空行和响应正文）</p><p>（4）客户与服务器关闭连接</p><ul><li>客户与服务器之间的HTTP连接是一种一次性连接，它限制每次连接只处理一个请求，当服务器返回本次请求的应答后便立即关闭连接，下次请求再重新建立连接。</li><li>这种一次性连接主要考虑到WWW服务器面向的是Internet中成干上万个用户，且只能提供有限个连接，故服务器不会让一个连接处于等待状态，及时地释放连接可以大大提高服务器的执行效率。</li></ul><hr><h3 id="2、HTTP请求方法（9种）"><a href="#2、HTTP请求方法（9种）" class="headerlink" title="2、HTTP请求方法（9种）"></a>2、HTTP请求方法（9种）</h3><ul><li><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法（常用的请求方法是GET和POST）</p></li><li><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p></li></ul><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h4 id="2-1、GET和POST方法区别"><a href="#2-1、GET和POST方法区别" class="headerlink" title="2.1、GET和POST方法区别"></a>2.1、GET和POST方法区别</h4><ol><li><p><strong>使用方式</strong>：GET是从服务器上获取数据；POST是向服务器传送数据。</p></li><li><p><strong>提交方式</strong>：在客户端，GET通过URL提交数据，数据在URL中可见；POST把数据放在form的数据体内提交。</p></li><li><p><strong>数据容量</strong>：GET提交的数据最多只有1024字节；POST提交的数据量无限制。</p></li><li><p><strong>数据安全</strong>：使用 GET 参数会显示在地址栏上，而 POST 不会，所以如果包含<strong>敏感数据</strong>，为了安全，用POST。</p></li></ol><table><thead><tr><th align="left"></th><th align="left">GET</th><th align="left">POST</th></tr></thead><tbody><tr><td align="left">后退按钮/刷新</td><td align="left">无害</td><td align="left">数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td align="left">书签</td><td align="left">可收藏为书签</td><td align="left">不可收藏为书签</td></tr><tr><td align="left">缓存</td><td align="left">能被缓存</td><td align="left">不能缓存</td></tr><tr><td align="left">编码类型</td><td align="left">application/x-www-form-urlencoded</td><td align="left">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td align="left">历史</td><td align="left">参数保留在浏览器历史中。</td><td align="left">参数不会保存在浏览器历史中。</td></tr><tr><td align="left">对数据长度的限制</td><td align="left">当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td align="left">无限制。</td></tr><tr><td align="left">对数据类型的限制</td><td align="left">只允许 ASCII 字符。</td><td align="left">没有限制。也允许二进制数据。</td></tr><tr><td align="left">安全性</td><td align="left">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td align="left">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td align="left">可见性</td><td align="left">数据在 URL 中对所有人都是可见的。</td><td align="left">数据不会显示在 URL 中。</td></tr></tbody></table><h4 id="2-2、何时使用GET？"><a href="#2-2、何时使用GET？" class="headerlink" title="2.2、何时使用GET？"></a>2.2、何时使用GET？</h4><p>检索信息时一般用GET方法，如检索文档、图表、或数据库查询结果。要检索的信息作为字符序列传递，称为查询字符串。GET方法是表单默认的方法。</p><p>GET 请求的查询字符串（名称/值对）是在 URL 中发送的：</p><p><code>/test/demo_form.asp?name1=value1&amp;name2=value2</code></p><p>有关 GET 请求的其他一些注释：</p><ul><li>GET 请求可被缓存</li><li>GET 请求保留在浏览器历史记录中</li><li>GET 请求可被收藏为书签</li><li>GET 请求不应在处理敏感数据时使用</li><li>GET 请求有长度限制</li><li>GET 请求只应当用于取回数据</li></ul><h4 id="2-3、何时使用POST"><a href="#2-3、何时使用POST" class="headerlink" title="2.3、何时使用POST"></a>2.3、何时使用POST</h4><p>POST 请求的查询字符串（名称/值对）是在 HTTP 消息主体中发送的：</p><pre><code>POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2</code></pre><p>有关 POST 请求的其他一些注释：</p><ul><li>POST 请求不会被缓存</li><li>POST 请求不会保留在浏览器历史记录中</li><li>POST 不能被收藏为书签</li><li>POST 请求对数据长度没有要求</li></ul><hr><h3 id="3、HTTP状态码"><a href="#3、HTTP状态码" class="headerlink" title="3、HTTP状态码"></a>3、HTTP状态码</h3><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。</p><p>HTTP状态码共分为5种类型：</p><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息 —— 服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功 —— 操作被成功接收并处理（如200：请求成功，其后是对GET和POST请求的应答文档）</td></tr><tr><td align="left">3**</td><td align="left">重定向 —— 需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误 —— 请求包含语法错误或无法完成请求（如400：Bad Request 服务器未能理解请求、404：Not Found 服务器无法找到被请求的页面。）</td></tr><tr><td align="left">5**</td><td align="left">服务器错误 —— 服务器在处理请求的过程中发生了错误（如500：Internal Server Error内部服务器错误，请求未完成。服务器遇到不可预知的情况。）</td></tr></tbody></table><hr><h3 id="4、-什么是HTTPS"><a href="#4、-什么是HTTPS" class="headerlink" title="4、 什么是HTTPS"></a>4、 什么是HTTPS</h3><ul><li><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是<strong>以安全为目标</strong>的HTTP通道。</p></li><li><p>简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。</p></li></ul><p><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/HTTPS.jpg" alt="图解" title="图解"></p><p>有两种基本的加解密算法类型：</p><ol><li><p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</p></li><li><p>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p></li></ol><p><strong>https通信的优点：</strong></p><ul><li>客户端产生的密钥只有客户端和服务器端能得到</li><li>加密的数据只有客户端和服务器端才能得到明文</li><li>客户端到服务端的通信是安全的。</li></ul><hr><blockquote><p><a href="https://baike.baidu.com/item/HTTP/243074" target="_blank" rel="noopener">百度百科 HTTP</a></p><p><a href="https://www.runoob.com/http/http-tutorial.html" target="_blank" rel="noopener">菜鸟教程|HTTP</a></p><p><a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">W3school|HTTP</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组查找特定组合</title>
      <link href="/2020/07/09/er-wei-shu-zu-cha-zhao-te-ding-zu-he/"/>
      <url>/2020/07/09/er-wei-shu-zu-cha-zhao-te-ding-zu-he/</url>
      
        <content type="html"><![CDATA[<h3 id="舍友面试看见的一道算法题"><a href="#舍友面试看见的一道算法题" class="headerlink" title="舍友面试看见的一道算法题"></a>舍友面试看见的一道算法题</h3><p><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/wordsArray.png" alt="题目" title="就这！做了半天！"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Count</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//定义要查询的查询组合</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> apple <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//记录查询的下标</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//记录次数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//题目要求查询的二维数组</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> <span class="token punctuation">{</span>                <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'h'</span><span class="token punctuation">,</span><span class="token string">'x'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span><span class="token string">'i'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//开始查找</span>        <span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.首先遍历所有,找出a</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> c<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>apple<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 2.从a开始,遍历周围,查找下一个目标字符</span>                    <span class="token function">findChar</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>apple<span class="token punctuation">[</span><span class="token operator">++</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//每次查找完a,清空下标</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------- 一个'a'查找完毕 -----------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"总次数："</span><span class="token operator">+</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//定义找到的 apple[index] 字符坐标为 (xEnd,yEnd)</span>    <span class="token comment" spellcheck="true">//它的上一个坐标为 (xStart,yStart) ————>防止重复查找</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">findChar</span><span class="token punctuation">(</span><span class="token keyword">int</span> xStart<span class="token punctuation">,</span> <span class="token keyword">int</span> yStart<span class="token punctuation">,</span><span class="token keyword">int</span> xEnd<span class="token punctuation">,</span><span class="token keyword">int</span> yEnd<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">,</span><span class="token keyword">char</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>xEnd<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1、在第一行</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>xEnd<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token punctuation">(</span>xEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本行以及下一行</span>                <span class="token function">loopY</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span>yStart<span class="token punctuation">,</span>xEnd<span class="token punctuation">,</span> yEnd<span class="token punctuation">,</span> i<span class="token punctuation">,</span> c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> xEnd<span class="token operator">==</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//2、在最后行</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token punctuation">(</span>xEnd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>xEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本行以及上一行</span>                <span class="token function">loopY</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span>yStart<span class="token punctuation">,</span>xEnd<span class="token punctuation">,</span> yEnd<span class="token punctuation">,</span> i<span class="token punctuation">,</span> c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//3、在中间行</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token punctuation">(</span>xEnd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token punctuation">(</span>xEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本行及上下两行</span>                <span class="token function">loopY</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span>yStart<span class="token punctuation">,</span>xEnd<span class="token punctuation">,</span> yEnd<span class="token punctuation">,</span> i<span class="token punctuation">,</span> c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//判断列的位置是否在边缘，然后分情况循环查询</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loopY</span><span class="token punctuation">(</span><span class="token keyword">int</span> xStart<span class="token punctuation">,</span> <span class="token keyword">int</span> yStart<span class="token punctuation">,</span><span class="token keyword">int</span> xEnd<span class="token punctuation">,</span> <span class="token keyword">int</span> yEnd<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">,</span><span class="token keyword">char</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>yEnd<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//在第一列</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> yEnd<span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token punctuation">(</span>yEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本列以及右一列</span>                <span class="token function">check</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span> yStart<span class="token punctuation">,</span> xEnd<span class="token punctuation">,</span>yEnd<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//符合条件，下一轮寻找</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> yEnd<span class="token operator">==</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>xEnd<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//在最后列</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>yEnd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>yEnd <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本列以及左一列</span>                <span class="token function">check</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span> yStart<span class="token punctuation">,</span> xEnd<span class="token punctuation">,</span>yEnd<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//符合条件，下一轮寻找</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//在中间列</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>yEnd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token punctuation">(</span>yEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本列，及左右列</span>                <span class="token function">check</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span> yStart<span class="token punctuation">,</span> xEnd<span class="token punctuation">,</span>yEnd<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//符合条件，下一轮寻找</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//开始检验，符合条件回调继续查询</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span> xStart<span class="token punctuation">,</span> <span class="token keyword">int</span> yStart<span class="token punctuation">,</span><span class="token keyword">int</span> xEnd<span class="token punctuation">,</span> <span class="token keyword">int</span> yEnd<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">,</span><span class="token keyword">char</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>xStart<span class="token operator">==</span>i <span class="token operator">&amp;&amp;</span> yStart<span class="token operator">==</span>j<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//排除上一个点</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>xEnd<span class="token operator">==</span>i <span class="token operator">&amp;&amp;</span> yEnd<span class="token operator">==</span>j<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//排除自身</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[debug]从第%d行,第%d列————>找到 第%d行,第%d列: %c 字母.\n"</span><span class="token punctuation">,</span>                    <span class="token punctuation">(</span>xEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>yEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> apple<span class="token punctuation">[</span>apple<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//找到目标</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[debug]第%d次找到目标e\n"</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                num<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//计数加一</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">findChar</span><span class="token punctuation">(</span>xEnd<span class="token punctuation">,</span>yEnd<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>apple<span class="token punctuation">[</span><span class="token operator">++</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//符合条件，下一轮寻找</span>            <span class="token operator">--</span>index<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//找完之后，回到上一个节点，继续找</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="程序结果："><a href="#程序结果：" class="headerlink" title="程序结果："></a>程序结果：</h3><p>[debug]从第1行,第1列————&gt;找到 第1行,第2列: p 字母.<br>[debug]从第1行,第2列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第1次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第2次找到目标e<br>[debug]从第1行,第2列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第3次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第4次找到目标e<br>[debug]从第1行,第1列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第1行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第5次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第6次找到目标e<br>[debug]从第2行,第2列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第7次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第8次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第4行,第2列: l 字母.<br>[debug]从第4行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第9次找到目标e<br>[debug]从第4行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第10次找到目标e<br>———- 一个’a’查找完毕 ———–<br>[debug]从第2行,第4列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第1行,第2列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第11次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第12次找到目标e<br>[debug]从第2行,第3列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第13次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第14次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第4行,第2列: l 字母.<br>[debug]从第4行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第15次找到目标e<br>[debug]从第4行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第16次找到目标e<br>[debug]从第2行,第4列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第17次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第18次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第19次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第20次找到目标e<br>——— 一个’a’查找完毕 ———–<br>[debug]从第3行,第4列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第1行,第2列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第21次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第22次找到目标e<br>[debug]从第2行,第3列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第23次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第24次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第4行,第2列: l 字母.<br>[debug]从第4行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第25次找到目标e<br>[debug]从第4行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第26次找到目标e<br>[debug]从第3行,第4列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第27次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第28次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第29次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第30次找到目标e<br>——— 一个’a’查找完毕 ———–<br>[debug]从第4行,第4列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第31次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第32次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第33次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第34次找到目标e<br>——— 一个’a’查找完毕 ———–<br>总次数：34</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>不能空想，要模仿计算机，写出执行步骤，判断逻辑。</li><li>可别再复制黏贴了，就一个 x 和 y 写混了，改了一早上，佛了。</li><li>多写注释，不然过了一晚上，自己的代码都看懵了。</li></ul><hr><p>其实本次实现还不够完善，因为字符里面只有2个 ‘p’ 是重复的，偷懒省去了很多判断。</p><p>上面的代码只取了上一个节点的坐标，保证2个 ‘p’ 没有重复，没有判断的5个点的坐标。</p><hr><h6 id="嘤嘤嘤"><a href="#嘤嘤嘤" class="headerlink" title="嘤嘤嘤"></a>嘤嘤嘤</h6>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2020/07/07/java-yu-yan-gai-shu/"/>
      <url>/2020/07/07/java-yu-yan-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h2><h4 id="一、Java不同开发版本"><a href="#一、Java不同开发版本" class="headerlink" title="一、Java不同开发版本"></a>一、Java不同开发版本</h4><ul><li>JavaSE：Java Standard Edition —— 基础的控制台程序，桌面应用。</li><li>JavaME：Java Micro Edition (缩小版) —— 电子词典程序，pda软件，机顶盒软件……</li><li>JavaEE：Java Enterprise Edition (企业版) —— Web网站(如：淘宝、京东)。</li></ul><h4 id="二、Java特点与特性"><a href="#二、Java特点与特性" class="headerlink" title="二、Java特点与特性"></a>二、Java特点与特性</h4><h4 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h4><ul><li>简单易用：<ul><li>深层封装语言, 屏蔽很多底层细节, 提供很多工具库。<br>没有指针 (不直接操作内存数据, 不能操作寄存器)。<br>有垃圾回收机制, 帮我们处理内存垃圾数据。</li></ul></li><li>面向对象</li><li>可移植性</li></ul><h4 id="2-2-三大特性"><a href="#2-2-三大特性" class="headerlink" title="2.2 三大特性"></a>2.2 三大特性</h4><ul><li><p>封装 —— 将若干的数据(变量, 方法, 类) 封装为一个整体。</p></li><li><p>继承 —— 从某个资源中继承它的资源 (资源复用, 资源扩展)。</p></li><li><p>多态 —— 某个事物的多种形态、某种行为不同的表达方式。</p></li></ul><h4 id="三、注释"><a href="#三、注释" class="headerlink" title="三、注释"></a>三、注释</h4><blockquote><p>//单行注释</p></blockquote><blockquote><p>/*<br>    多行注释<br>    多行注释<br>    多行注释<br>    多行注释<br>*/</p></blockquote><pre><code>文档注释：    /**     *    @param  参数名     *    @return  指明返回值的含义     *    @exception  完整类名     *    @deprecated  不建议使用、将来可能摈弃的说明     */生成文档注释：javadoc        -d            apidoc        -windowtitle  标题        -doctitle     文档标题        xx.java       Java 源文件 </code></pre><h4 id="四、JVM、JRE、JDK"><a href="#四、JVM、JRE、JDK" class="headerlink" title="四、JVM、JRE、JDK"></a>四、JVM、JRE、JDK</h4><ol><li><p>什么是JVM？</p><p>Java Virtual Machine，Java虚拟机。</p></li><li><p>什么是JRE？</p><p>Java运行时环境：JavaSE（基础类库）+ JVM</p></li><li><p>什么是JDK？</p><p>Java开发工具包：JRE + 开发工具</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2020/07/01/javascript/"/>
      <url>/2020/07/01/javascript/</url>
      
        <content type="html"><![CDATA[<h3 id="1-为什么要学JavaScript？"><a href="#1-为什么要学JavaScript？" class="headerlink" title="1. 为什么要学JavaScript？"></a>1. 为什么要学JavaScript？</h3><ul><li>表单的注册 —— 表单的页面验证（减轻服务器的压力）</li><li>页面动态效果 —— 树形菜单的使用</li><li>页面内容的动态展示 —— 表单的动态验证、表格的动态数据</li></ul><h3 id="2-JavaScript的特点"><a href="#2-JavaScript的特点" class="headerlink" title="2. JavaScript的特点"></a>2. JavaScript的特点</h3><ul><li>HTML页面添加交互行为</li><li>语法与 Java 类似</li><li>解释性语言，可以边执行边解释</li></ul><h3 id="3-三大组成部分"><a href="#3-三大组成部分" class="headerlink" title="3. 三大组成部分"></a>3. 三大组成部分</h3><ul><li><p>ECMAScript：<a href="http://baike.baidu.com/view/3986646.htm" target="_blank" rel="noopener">Ecma国际</a>以JavaScript为基础制定了<a href="http://baike.baidu.com/view/810176.htm" target="_blank" rel="noopener">ECMAScript</a>标准。</p><ul><li>（函数）</li></ul></li><li><p>DOM：文档对象模型，简单的说，document对象和文档中其他元素</p><ul><li>（如表单、图像、超链接等）</li></ul></li><li><p>BOM：浏览器对象模型，该对象模型提供了独立于内容、可以与浏览器窗口进行互动的对象结构</p><ul><li>（弹窗）</li></ul></li></ul><h3 id="4-引入位置"><a href="#4-引入位置" class="headerlink" title="4. 引入位置"></a>4. 引入位置</h3><ul><li><p><strong>标签中直接使用</strong></p><ul><li><code>&lt;input name=&quot;btn&quot; type=&quot;button&quot; value=&quot;弹出消息框&quot; onclick=&quot;javascript:alert(&#39;欢迎你&#39;);&quot;/&gt;</code></li></ul></li><li><p><strong>&lt;head&gt;标签中调用</strong></p><ul><li><strong>内部调用</strong>  </li></ul><pre><code>&lt;script type=”text/javascript”&gt;        Javascript语句;&lt;/script&gt;</code></pre><ul><li><p><strong>外部调用</strong></p><p><code>&lt;script language=”JavaScript” src=”路径”&gt;&lt;/script&gt;</code></p></li></ul></li><li><p><strong>页面任意位置</strong></p><ul><li>需要调用的元素要保证解析完成（在body里放在需要调用的元素语句后面，最好放在末尾）</li></ul></li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化输出</title>
      <link href="/2020/06/30/ge-shi-hua-shu-chu/"/>
      <url>/2020/06/30/ge-shi-hua-shu-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><h4 id="System-out-printf-方法的使用"><a href="#System-out-printf-方法的使用" class="headerlink" title="System.out.printf(); 方法的使用"></a>System.out.printf(); 方法的使用</h4><table><thead><tr><th>占位符</th><th>说明</th><th>限定位宽</th><th>输出</th></tr></thead><tbody><tr><td>%s</td><td>以字符串的形式输出</td><td>%8s</td><td>最多8个字符</td></tr><tr><td>%f</td><td>以浮点类型的形式输出</td><td>%[位宽] (.) [保留小数个数]f</td><td></td></tr><tr><td>%c</td><td>以字符类型的形式输出</td><td></td><td></td></tr><tr><td>%d</td><td>以十进制整数形式输出</td><td></td><td></td></tr><tr><td>%o</td><td>以八进制整数形式输出</td><td></td><td></td></tr><tr><td>%x</td><td>以十六进制整数形式输出</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown学习</title>
      <link href="/2020/06/28/markdown-xue-xi/"/>
      <url>/2020/06/28/markdown-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习</h1><h3 id="1-什么是Markdown？"><a href="#1-什么是Markdown？" class="headerlink" title="1.什么是Markdown？"></a>1.什么是Markdown？</h3><p>​        Markdown是一种可以使用普通文本编辑器编写的<a href="https://baike.baidu.com/item/标记语言/5964436" target="_blank" rel="noopener">标记语言</a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>​        Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p><h3 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h3><hr><h4 id="2-1常用语法："><a href="#2-1常用语法：" class="headerlink" title="2.1常用语法："></a>2.1常用语法：</h4><table><thead><tr><th>描述</th><th align="center">输入</th><th align="center">显示效果</th></tr></thead><tbody><tr><td>斜体</td><td align="center">*文本*</td><td align="center"><em>嘤嘤嘤</em></td></tr><tr><td>粗体</td><td align="center">**文本**</td><td align="center"><strong>嘤嘤嘤</strong></td></tr><tr><td>斜体加粗</td><td align="center">***文本***</td><td align="center"><strong><em>嘤嘤嘤</em></strong></td></tr><tr><td>删除线</td><td align="center">~~文本~~</td><td align="center"><del>嘤嘤嘤</del></td></tr><tr><td>链接</td><td align="center">[百度一下](<a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a>)</td><td align="center"><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></td></tr><tr><td>图片</td><td align="center">![图片下方文字](图片地址 &quot;鼠标悬停时显示的文字&quot;)</td><td align="center">ps: 悬停文字可不要</td></tr><tr><td>无序列表</td><td align="center">* 文本</td><td align="center">ps:- 文本 或 + 文本 也行</td></tr><tr><td>有序列表</td><td align="center">1. 文本</td><td align="center"></td></tr><tr><td>引用</td><td align="center">&gt; 文本</td><td align="center">可以嵌套，如&gt;&gt;、&gt;&gt;&gt;……</td></tr><tr><td>分割线</td><td align="center">- - - 或 ***(3个或以上)</td><td align="center"></td></tr><tr><td>代码</td><td align="center">`单行`          ```多行```</td><td align="center"></td></tr></tbody></table><blockquote><blockquote><p>百度百科（引用示例：&gt;&gt;）</p></blockquote></blockquote><pre class="line-numbers language-示例"><code class="language-示例">示例：多行代码展示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>单行代码展示</code></p><pre class="line-numbers language-表格"><code class="language-表格">|表头|表头|表头||---|:--:|---:||内容|内容|内容||内容|内容|内容|第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个 文字默认居左-两边加：表示文字居中-右边加：表示文字居右 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="2-2-转义字符："><a href="#2-2-转义字符：" class="headerlink" title="2.2 转义字符："></a>2.2 转义字符：</h4><ol><li><p>特殊字符需要用转义字符 \ 输出。 </p></li><li><p>HTML中的转义字符：</p></li></ol><table><thead><tr><th>显示结果</th><th>描述</th><th>输入</th><th>实体编号</th></tr></thead><tbody><tr><td>&nbsp;</td><td>空格</td><td>&amp;nbsp;</td><td>&amp;#160;</td></tr><tr><td>&lt;</td><td>小于</td><td>&amp;lt;</td><td>&amp;#60;</td></tr><tr><td>&gt;</td><td>大于</td><td>&amp;gt;</td><td>&amp;#62;</td></tr><tr><td>&amp;</td><td>和</td><td>&amp;amp;</td><td>&amp;#38;</td></tr><tr><td>&quot;</td><td>双引</td><td>&amp;quot;</td><td>&amp;#34;</td></tr><tr><td>&#39;</td><td>单引</td><td>&amp;apos;</td><td>&amp;#39;</td></tr><tr><td>&divide;</td><td>除号</td><td>&amp;divide;</td><td>&amp;#247;</td></tr><tr><td>&copy;</td><td>版权</td><td>&amp;copy;</td><td>&amp;#169;</td></tr><tr><td>&reg;</td><td>注册商标</td><td>&amp;reg;</td><td>&amp;#174;</td></tr></tbody></table><hr><h4 id="2-3-标题"><a href="#2-3-标题" class="headerlink" title="2.3 标题"></a>2.3 标题</h4><p>对应个数的 “#” 来表示标题级别。</p><p># 一级标题（对应&lt;h1 /&gt;）</p><p>## 二级标题（对应&lt;h2 /&gt;）</p><p>### 三级标题（对应&lt;h3 /&gt;）</p><p>#### 四级标题（对应&lt;h4 /&gt;）</p><p>##### 五级标题（对应&lt;h5 /&gt;）</p><p>###### 六级标题（对应&lt;h6 /&gt;）</p><hr>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
