<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Session和Cookie</title>
      <link href="/2020/07/19/session-he-cookie/"/>
      <url>/2020/07/19/session-he-cookie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Session"><a href="#一、Session" class="headerlink" title="一、Session"></a>一、Session</h2><h3 id="1-1、什么是HttpSession？"><a href="#1-1、什么是HttpSession？" class="headerlink" title="1.1、什么是HttpSession？"></a>1.1、什么是HttpSession？</h3><ul><li>http协议的一次会话，提供了存储和返回标准会话属性的方法。</li><li>标准会话属性如会话标识符、应用数据等，都以“名字——值”对的形式保存在服务器。</li><li>也就是说，HttpSession接口提供了一种<strong>把对象存到内存</strong>、在统一用户的<strong>后继请求中</strong>提取这些对象的标准方法。</li></ul><p>当用户打开浏览器，访问某个网站时，服务器就会在服务器的内存中为该浏览器分配一个空间，该空间被这个浏览器独占，这个空间就是Session。Session的数据默认存在时间为30分钟（Tomcat），也可以自行修改。</p><h3 id="1-2、Session可以用来做什么？"><a href="#1-2、Session可以用来做什么？" class="headerlink" title="1.2、Session可以用来做什么？"></a>1.2、Session可以用来做什么？</h3><p>1、 网上商城中的购物车</p><p>2、 保存登录的用户信息</p><p>3、 将某些数据放到session中，供同一用户的各个页面使用</p><p>4、 防止用户的非法登录到某个页面</p><p>5、 ……….很多很多😄</p><h4 id="如何使用session"><a href="#如何使用session" class="headerlink" title="如何使用session"></a>如何使用session</h4><ul><li>获得session</li></ul><p><code>HttpSession session = request.getSession();</code></p><pre><code>//参数为true时,若存在会话,则返回该会话,否则 new 一个会话;//参数为false时,如存在会话,则返回该会话,否则返回NULL;getSession(boolean flag)getSession()相当于getSession(true);</code></pre><ul><li>添加值到session</li></ul><p><code>session.setAttribute(String name,Objct val);</code></p><ul><li>从session中获得属性值</li></ul><p><code>String name = session.getAttribute(String name);</code></p><ul><li>从session中删除某个属性</li></ul><p><code>session.removeAttribute(String name);</code></p><ul><li>设置Session的存活期限： </li></ul><p><code>setMaxInactiveInterval(int interval);</code>  </p><p>设置请求间隔时间（单位是秒），当浏览器超出interval秒还没有请求该应用的话就清除该Session。（如果在设定时间内访问，则会从最后一次访问时间点重新开始计算存活时间）</p><p>注意：如果interval为0或负则表示Session可以无限存活（除非关闭Web容器）</p><hr><h2 id="二、Cookie"><a href="#二、Cookie" class="headerlink" title="二、Cookie"></a>二、Cookie</h2><h3 id="2-1、Cookie的起源"><a href="#2-1、Cookie的起源" class="headerlink" title="2.1、Cookie的起源"></a>2.1、Cookie的起源</h3><p>Cookie最早出现在网景公司的雇员Lou Montulli在1993年的时候发明。</p><p>​        Cookie是由服务器端生成，一般发送给浏览器，<strong>浏览器会将cookie的key/value保存到某个目录下</strong>的文本中。Cookie名称和值可以由服务器端自定义，对于JSP而言也可以直接写入jsessionid，这样服务器可以知道该用户是否合法用户以及是否需要重新登录。</p><h4 id="Cookie使用"><a href="#Cookie使用" class="headerlink" title="Cookie使用"></a>Cookie使用</h4><p>1、 创建cookie（服务端创建）</p><p><code>Cookie cook = new Cookie(String key,String value);</code></p><p>2、 将创建好的cookie添加到客户端</p><p><code>response.addCookie(cook);</code></p><p>3、 如何读取cookie(从客户端读取到服务端中)</p><p><code>request.getCookies();</code></p><pre><code>//获取cookie，cookie可能是多个，所以返回一组cookieCookie[] cook = request.getCookies();if(cook!=null){    for(int i=0;i&lt;cook.length;i++){        //获得cookie中的元素        Cookie co = cook[i];        //通过判断是否有需要的cookie，co.getName()获得cookie的名字        if(co.getName().equals(&quot;name&quot;)){            name = co.getValue();    //读取用户名            co.setMaxAge(0);    //时效为0，cookie失效        }        if(co.getName().equals(&quot;pwd&quot;)){            pwd = co.getValue();    //读取密码            co.setMaxAge(0);    //时效为0，cookie失效        }    }}</code></pre><p>4、 设置cookie存在时间</p><p>Cooker.setMaxAge(秒)</p><p>5、 删除cookie，将cookie的SetMaxAge时间设置为0</p><h4 id="Cookie的生命周期"><a href="#Cookie的生命周期" class="headerlink" title="Cookie的生命周期"></a>Cookie的生命周期</h4><ul><li>Cookie可以保持登录信息到用户下次与服务器的会话<ul><li>换句话说，下次访问同一网站时，用户不必输入用户名和密码就可以登陆了。</li></ul></li><li>Cookie在生成时就会<strong>被指定一个expire值</strong>，这就是cookie的生命周期，超出周期cookie就会被清除。<ul><li>有些页面将cookie的生存周期设置为0，这样在关闭页面是，就马上清除cookie，不会记录用户信息，更加安全。</li></ul></li></ul><h4 id="Cookie的优缺点"><a href="#Cookie的优缺点" class="headerlink" title="Cookie的优缺点"></a>Cookie的优缺点</h4><ul><li>优点</li></ul><p><strong>方便用户登陆网站</strong>——保存有用户信息，可用于自动登陆等</p><p><strong>独立的Cookie空间</strong>——在一台计算机中安装多个浏览器，每个浏览器都会在各自独立的空间存放cookie。cookie中不但可以确认用户，还能包含计算机信息和浏览器信息，所以一个用户用不同的浏览器登录或使用不同的计算机登录，都会得到不同的cookie信息。</p><ul><li>缺点</li></ul><p><strong>识别不精确</strong>——对于在同一台计算机上使用同一浏览器的多用户群，cookie不会区分他们的身份，除非他们使用不同的用户名登录</p><p><strong>个人隐私和安全</strong>——因为会保存计算机信息和用户信息，这些都为敏感信息，有可能会被泄露</p><hr><h2 id="三、Session和Cookie的区别"><a href="#三、Session和Cookie的区别" class="headerlink" title="三、Session和Cookie的区别"></a>三、Session和Cookie的区别</h2><h3 id="3-1、存在的位置"><a href="#3-1、存在的位置" class="headerlink" title="3.1、存在的位置"></a>3.1、存在的位置</h3><ul><li>Session对象保存在<strong>服务器</strong>内存中</li><li>Cookie对象保存在<strong>客户端</strong>的硬盘或内存中</li></ul><h3 id="3-2、安全性"><a href="#3-2、安全性" class="headerlink" title="3.2、安全性"></a>3.2、安全性</h3><ul><li>Session的安全性较高，因为它存放于服务端</li><li>Cookie安全性相对较低，因为它保存在客户端，任何人都可以获得你的账号和密码</li></ul><h3 id="3-3、网络传输"><a href="#3-3、网络传输" class="headerlink" title="3.3、网络传输"></a>3.3、网络传输</h3><ul><li>Session因为保存在服务端，不需要传输</li><li>cookie保存在客户端，需要进行网络传输</li></ul><h3 id="3-4、生命周期"><a href="#3-4、生命周期" class="headerlink" title="3.4、生命周期"></a>3.4、生命周期</h3><ul><li><p>Session的生命周期是一个<strong>间隔</strong>，从创建的时候开始计时</p><ul><li>如果在生命周期内没有访问Session，那么Session无效</li><li>如果在生命周期内访问Session，那么它的生命周期<strong>重新计算</strong></li></ul></li><li><p>Cookie的生命周期是<strong>累计</strong>的，从创建的时候开始计时</p><ul><li>生命周期到了之后Cookie的生命周期结束，cookie就无效了</li><li>就算周期内再访问，也<strong>不会重新计时</strong>，不会刷新</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet使用分页技术</title>
      <link href="/2020/07/18/servlet-zhong-shi-yong-fen-ye/"/>
      <url>/2020/07/18/servlet-zhong-shi-yong-fen-ye/</url>
      
        <content type="html"><![CDATA[<h3 id="Servlet中使用分页技术"><a href="#Servlet中使用分页技术" class="headerlink" title="Servlet中使用分页技术"></a>Servlet中使用分页技术</h3><p>为什么要使用分页？</p><ul><li>页面数据过多，无法一次性展示完成，需要分页显示。</li></ul><p>分页的需要准备的数据：</p><ul><li>pageSize 每页多少条数据（程序设定）</li><li>pageNow 当前页（用户点击选择）</li><li>rowCount 一共多少条记录（根据数据库统计所得）</li><li>pageCount 一共多少页（根据总记录和每页记录展示数计算）</li></ul><p>pageCount 需要判断尾页是否为完整页面（展示记录是否刚好等于每页记录数）：</p><p><code>pageCount = rowCount%pageSize&gt;0 ? (rowCount/pageSize)+1 : rowCount/pageSize;</code></p><h4 id="1、页面对象类pageBean"><a href="#1、页面对象类pageBean" class="headerlink" title="1、页面对象类pageBean"></a>1、页面对象类pageBean</h4><pre><code>public class pageBean&lt;T&gt; {    private int rowCount;    // 数据总行数：去数据库查询(如果有模糊查询，根据条件查询)    private int pageSize=1;    // 页面展示行数：根据需求设置展示行数,注意程序的除0异常    private int pageNow;    // 当前页：根据前端点击改变,初次访问设置为1    private int pageCount;    // 页面总数    private List&lt;T&gt; list = new ArrayList&lt;&gt;();    // 存储当前页的数据    public int getRowCount() {        return rowCount;    }    public void setRowCount(int rowCount) {        this.rowCount = rowCount;        this.setPageCount();    //当总数据受到影响时,总页数也会受到影响,需要同步修改    }    public int getPageSize() {        return pageSize;    }    public void setPageSize(int pageSize) {        this.pageSize = pageSize;        this.setPageCount();    //当展示行数受到影响时,总页数也会受到影响,需要同步修改    }    public int getPageNow() {        return pageNow;    }    public void setPageNow(int pageNow) {        this.pageNow = pageNow;    }    public int getPageCount() {        return pageCount;    }    public void setPageCount() {        this.pageCount = this.rowCount % this.pageSize == 0 ? this.rowCount                / this.pageSize : this.rowCount / this.pageSize + 1;    }    public List&lt;T&gt; getList() {        return list;    }    public void setList(List&lt;T&gt; list) {        this.list = list;    }}</code></pre><h4 id="2、编写实体类Users"><a href="#2、编写实体类Users" class="headerlink" title="2、编写实体类Users"></a>2、编写实体类Users</h4><pre><code>public class Users {    private int uid;    private String account;    private String password;    private String uname;    private String address;    public int getUid() {        return uid;    }    public void setUid(int uid) {        this.uid = uid;    }    public String getAccount() {        return account;    }    public void setAccount(String account) {        this.account = account;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public String getUname() {        return uname;    }    public void setUname(String uname) {        this.uname = uname;    }    public String getAddress() {        return address;    }    public void setAddress(String address) {        this.address = address;    }    @Override    public String toString() {        return &quot;Users [uid=&quot; + uid + &quot;, account=&quot; + account + &quot;, password=&quot; + password        + &quot;, uname=&quot; + uname + &quot;, address=&quot; + address + &quot;]&quot;;    }}</code></pre><h4 id="3、分页功能核心"><a href="#3、分页功能核心" class="headerlink" title="3、分页功能核心"></a>3、分页功能核心</h4><pre><code>    //Dao层分页核心,获得页面类对象    @Override    public PageBean&lt;Users&gt; getPage(int pageNow) {    //传入pageNow当前展示页        PageBean&lt;Users&gt; pb = new PageBean&lt;&gt;();    //实例化pageBean        pb.setPageNow(pageNow);    //pageBean设置当前页        String sql = &quot;select count(*) from users&quot;;    //查询总数据        //[Tips] int queryCount(String sql,Object...obj)方法：返回int        int allRow = queryCount(sql);    //记录下查询出来的总行数        pb.setRowCount(allRow);            //pageBean设置总数据        sql = &quot;select * from users limit ?,?&quot;;        //执行分页查询        //[Tips] List&lt;T&gt; query(String sql,Object...obj)方法：返回ArrayList        //记录下查询出来的要展示的分页数据        List&lt;T&gt; list = query(sql, (pageNow-1)*pb.getPageSize(),pb.getPageSize())        pb.setList(list);    //pageBean放入查询出来的ArrayList        return pb;    //前端页面根据返回的pageBean展示内容    }</code></pre><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>对分页的小记录，还没有用上分页条件查询，写的乱乱的。。。</p><p>后面会重新梳理一遍/(ㄒoㄒ)/~~</p>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
            <tag> Servlet </tag>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建一个Servlet程序</title>
      <link href="/2020/07/18/chuang-jian-yi-ge-servlet-cheng-xu/"/>
      <url>/2020/07/18/chuang-jian-yi-ge-servlet-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、创建方式"><a href="#一、创建方式" class="headerlink" title="一、创建方式"></a>一、创建方式</h3><p>创建servlet两种方式：</p><ul><li>实现 servlet 接口</li></ul><pre><code>package com.wenah;import java.io.IOException;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class FirstServlet implements Servlet{    @Override    public void destroy() {        //销毁方法    }    @Override    public ServletConfig getServletConfig() {        //用来返回初始化参数和 ServletContext        //ServletContext 接口提供有关 servlet 的环境信息        return null;    }    @Override    public String getServletInfo() {        //有关 servlet 的信息，如作者、版本、版权        return null;    }    @Override    public void init(ServletConfig arg0) throws ServletException {        //初始化方法,初始化时执行一次,以后调用不会再执行    }    @Override    public void service(ServletRequest arg0, ServletResponse arg1)        throws ServletException, IOException {        //主要函数,在这里处理请求,编写所需要的功能    }}</code></pre><ul><li>继承 HttpServlet 类（下面介绍）</li></ul><h3 id="二、Servlet的创建"><a href="#二、Servlet的创建" class="headerlink" title="二、Servlet的创建"></a>二、Servlet的创建</h3><p>继承 HttpServlet 类的创建过程：</p><ol><li>创建动态Web工程：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710103200979.png" alt="image-20200710103200979" style="zoom: 20%;" /></li><li>输入项目名，下一步：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710103701244.png" alt="image-20200710103701244" style="zoom:20%;" /></li><li>默认，下一步：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710104106343.png" alt="image-20200710104106343" style="zoom:15%;" /></li><li>勾上自动生成web.xml，完成项目创建：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710104225015.png" alt="image-20200710104225015" style="zoom:20%;" /></li><li>生成的项目文件目录：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710104505378.png" alt="image-20200710104505378" style="zoom:20%;" /></li><li>在 <strong>src文件夹</strong> 创建servlet：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710104636476.png" alt="image-20200710104636476" style="zoom:20%;" /></li><li>新建第一个Servlet：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710105029823.png" alt="image-20200710105029823" style="zoom:25%;" /></li><li>设置映射：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710105345733.png" alt="image-20200710105345733" style="zoom:20%;" /></li><li>选择需要的方法：<img src="C:\Users\wenah阮\AppData\Roaming\Typora\typora-user-images\image-20200710105848006.png" alt="image-20200710105848006" style="zoom:25%;" /></li></ol><ul><li>生成测试类（自动生成@WebServlet注解）</li></ul><pre><code>package com.wenah.test;import java.io.IOException;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(&quot;/TestRequestServlet&quot;)public class TestRequestServlet extends HttpServlet {    private static final long serialVersionUID = 1L;//序列化相关    public void init(ServletConfig config) throws ServletException {}// 初始化方法    protected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException {        response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());    }    protected void doPost(HttpServletRequest request, HttpServletResponse response)    throws ServletException, IOException {        doGet(request, response);    }}</code></pre><ul><li>如果不使用注解，可以用 web.xml 设置映射</li></ul><pre><code>//web.xml设置：&lt;servlet&gt;    &lt;!-- servlet别名，和下面的对应 --&gt;    &lt;servlet-name&gt;TestRequestServlet&lt;/servlet-name&gt;    &lt;!-- servlet完整类名 --&gt;    &lt;servlet-class&gt;com.wenah.test.TestRequestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;!-- servlet别名，和上面的对应 --&gt;    &lt;servlet-name&gt;TestRequestServlet&lt;/servlet-name&gt;    &lt;!-- servlet映射地址(网页请求url) --&gt;    &lt;url-pattern&gt;/TestRequestServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;//等价于：@WebServlet(&quot;/TestRequestServlet&quot;)public class TestRequestServlet extends HttpServlet{    //类体......}</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet基础</title>
      <link href="/2020/07/18/servlet-ji-chu/"/>
      <url>/2020/07/18/servlet-ji-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Servlet概述"><a href="#一、Servlet概述" class="headerlink" title="一、Servlet概述"></a>一、Servlet概述</h3><h4 id="1-1、什么是Servlet？"><a href="#1-1、什么是Servlet？" class="headerlink" title="1.1、什么是Servlet？"></a>1.1、什么是Servlet？</h4><ul><li><p>Servlet（<strong>Server</strong> <strong>Applet</strong>）是 Java Servlet 的简称，称为<strong>小服务程序</strong>或<strong>服务连接器</strong>，用 Java 编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于<strong>交互式</strong>的浏览和生成数据，生成动态Web内容。</p></li><li><p>狭义的 Servlet 是指 Java 语言实现的<strong>一个接口</strong>，广义的Servlet是指<strong>任何实现了这个Servlet接口的类</strong>。</p><p>一般情况下，人们将Servlet理解为后者。</p></li><li><p>Servlet 的命名可以看出 sun 命名的特点，如 Applet 表示小应用程序；Scriptlet = Script + Applet，表示小脚本程序；同样 Servlet = Service + Applet，表示小服务程序。</p></li></ul><hr><h4 id="1-2、Servlet的生命周期"><a href="#1-2、Servlet的生命周期" class="headerlink" title="1.2、Servlet的生命周期"></a>1.2、Servlet的生命周期</h4><h5 id="一般情况下："><a href="#一般情况下：" class="headerlink" title="一般情况下："></a>一般情况下：</h5><ol><li><p><strong>客户端发送请求</strong> 到该 Servlet；</p></li><li><p>Web 容器<strong>解析请求</strong>；（比如Tomcat）</p></li><li><p>客户端的请求到达 Server，<strong>加载</strong> Servlet 类 <strong>到内存</strong>；</p><p>Server 创建一个<strong>请求对象</strong>处理客户端请求、创建一个<strong>响应对象</strong>响应客户端请求；</p></li><li><p><strong>实例化</strong> 并 <strong>调用</strong> <strong>init()</strong> <strong>方法</strong> 初始化该 Servlet；（init方法只会在初始化时<strong>执行一次</strong>，下次调用不会执行）</p></li><li><p>调用 <strong>service()</strong> ——根据请求方法不同调用doGet() 或者 doPost()来处理业务；</p><p>Server 激活 Servlet 的 service() 方法，传递请求和响应对象作为参数</p><p>此外还有doHead()、doPut()、doTrace()、doDelete()、doOptions()、destroy()；</p></li><li><p><strong>返回响应</strong>，输出响应信息；</p><p>service() 方法使用响应对象的方法，将响应传回Server，最终到达客户端。service()方法可能激活其它方法以处理请求，如 doGet() 或 doPost() 或程序员自己开发的新的方法。</p></li><li><p>调用 destory() 方法——关闭资源或销毁对象；（destory方法一般在<strong>Server关闭时调用</strong>）</p></li></ol><p><code>web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序。这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS或PWS都是这样的容器。一个服务器可以有多个容器。</code></p><p>对于更多的客户端请求，Server 创建新的请求和响应对象，仍然激活此 Servlet 的 service() 方法，将两个对象作为参数传递给它。如此重复以上的循环，但无需再次调用 init() 方法。一般 Servlet 只初始化一次(<strong>只有一个对象</strong>)。</p><hr><h5 id="Server-启动时强制装载和初始化特定的-Servlet"><a href="#Server-启动时强制装载和初始化特定的-Servlet" class="headerlink" title="Server 启动时强制装载和初始化特定的 Servlet"></a>Server 启动时强制装载和初始化特定的 Servlet</h5><p>加载和实例化 Servlet 一般是<strong>动态执行</strong>的。然而，Server 通常会提供一个管理的选项，用于在 Server 启动时强制装载和初始化特定的 Servlet。</p><ul><li>Servlet 的 init() 方法可配置为 Server 创建 Servlet 实例时调用，在 <code>web.xml</code> 中 <code>&lt;servlet&gt;</code> 标签下配置<code>&lt;load-on-startup&gt;</code> 标签，配置的值为整型，值越小 Servlet 的启动优先级越高。</li></ul><p>在servlet的配置当中，<code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code>的含义是：标记容器是否在<strong>启动的时候</strong>就加载这个servlet。</p><ul><li><p>当值为 <strong>0或者大于0</strong> 时，表示容器在应用<strong>启动时</strong>就加载这个 servlet；</p></li><li><p>当值为 <strong>负数时或者没有指定</strong> 时，则指示容器在该 servlet <strong>被请求时</strong> 才加载。</p></li><li><p><strong>正数的值越小</strong>，启动该 servlet 的<strong>优先级越高</strong>。</p></li></ul><hr><p><strong>比如 Tomcat7.0 的 web.xml 部分配置</strong>：(对于所有tomcat加载的web application都会应用，会和application本身指定的web.xml进行合并)</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;debug&lt;/param-name&gt;        &lt;param-value&gt;0&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;listings&lt;/param-name&gt;        &lt;param-value&gt;false&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- The mapping for the default servlet --&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><ol><li>该servlet的name为default,其对应的servlet-class类为org.apache.catalina.servlets.DefaultServlet。</li><li>对应的init-param标签中两个初始化参数:<ul><li>一个是 debug ,这个参数设置了 debug 的级别。</li><li>一个是 listings 参数，该参数的作用是当对应 URL 并没有对应一个资源时，是否要显示资源目录，该参数配置为了 false，也就是不显示。</li></ul></li><li>load-on-startup为1是说明当应用启动时就在加载该servlet。</li><li>DefaultServlet 的 servlet-mapping 配置的为：<strong>/</strong> ,处理所有的请求（请求优先级最低）<ul><li>一般只有defaultServlet会配置为/,如果自定义的Servlet也配置为/,那么将会覆盖defaultservlet的配置。</li><li>通过链接访问应用内的资源文件，例如.jpg,.html,.js这类的静态文件，就是 DefaultServlet 处理的请求。</li></ul></li></ol><hr><p>对于类似于 <strong>.jsp</strong> 的java动态服务页，我们可以直接通过一个URL例如 <strong>/index.jsp</strong> 来访问到该页面，这是因为在web.xml中有一个 <strong>JspServlet</strong> 来处理这类请求，即当用户请求的资源是一个jsp页面等时，访问的是JspServlet。</p><p>浏览器不能显示动态资源，JspServlet 将当前访问的 jsp 页面转换成静态的 html 页面，然后再响应给浏览器。</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;fork&lt;/param-name&gt;        &lt;param-value&gt;false&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;xpoweredBy&lt;/param-name&gt;        &lt;param-value&gt;false&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- The mappings for the JSP servlet --&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;    &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>JSP页的编译和执行Servlet， 是Tomcat支持JSP页面的机制。另外，这个servlet被映射的URL模式为”*.jsp”。 同时也支持一些初始化参数。它们都具有一些默认值。具体解释可以看 web.xml 中的注释。</p><hr><h5 id="关于-url-pattern-的匹配问题"><a href="#关于-url-pattern-的匹配问题" class="headerlink" title="关于 url-pattern 的匹配问题"></a>关于 url-pattern 的匹配问题</h5><ul><li><p>对于<code>&lt;url-pattern&gt;&lt;/url-pattern&gt;</code>一个Servlet可以配置多个 <strong>url-pattern</strong></p></li><li><p>优先级：完全匹配 &gt; 目录匹配 &gt; 扩展名匹配</p></li><li><p>在优先级相同的情况下，先访问范围更确定的url配置</p></li></ul><hr><h5 id="Servlet容器对Servlet的管理"><a href="#Servlet容器对Servlet的管理" class="headerlink" title="Servlet容器对Servlet的管理"></a>Servlet容器对Servlet的管理</h5><ul><li><p>Servlet 容器的主要功能是将<strong>请求转发</strong>到正确的 Servlet 进行处理，并在 JVM 处理完后将<strong>动态生成的结果返回</strong>到正确的位置。</p></li><li><p>在大多数情况下， Servlet 容器在单个 JVM 中运行，但是当容器需要多个 JVM 时，会有一些其它的解决方案。</p></li><li><p>Servlet 容器允许 JVM 在处理每个请求时使用 <strong>单独的</strong> <strong>Java</strong> <strong>线程</strong>，这是 Servlet 容器的一个主要优点。</p><ul><li>每个线程执行一个单一的 Servlet 实例的 service() 方法</li></ul></li><li><p>当 Server 不再需要 Servlet 时（一般当 Server 关闭时），Server 调用 Servlet 的 destroy() 方法。</p></li></ul><hr><h4 id="1-3、Servlet-线程安全问题"><a href="#1-3、Servlet-线程安全问题" class="headerlink" title="1.3、Servlet 线程安全问题"></a>1.3、Servlet 线程安全问题</h4><p>在 Web 应用程序中，一个 Servlet 在一个时刻可能被多个用户同时访问。这时 Web 容器将为每个用户创建一个线程来执行 Servlet。如果 Servlet 不涉及共享资源的问题，不必关心多线程问题。但如果 Servlet 需要共享资源，需要保证 Servlet 是线程安全的。</p><p><strong>线程安全的Servlet的一些方案：</strong></p><ul><li>用方法的<strong>局部变量</strong>保存请求中的<strong>专有数据</strong>。对方法中定义的局部变量，进入方法的每个线程都有自己的一份方法变量拷贝。任何线程都不会修改其他线程的局部变量。<ul><li>如果要在不同的请求之间<strong>共享数据</strong>，应该<strong>使用会话</strong>来共享这类数据。</li></ul></li><li>只用 Servlet 的<strong>成员变量</strong>来存放那些<strong>不会改变的数据</strong>。有些数据在 Servlet 生命周期中不发生任何变化，通常是在初始时确定的，这些数据可以使用成员变量保存，如数据库连接名称、其他资源的路径等。</li><li>对可能被请求<strong>修改</strong>的成员变量<strong>同步</strong>。有时数据成员变量或者环境属性可能被请求修改。当访问这些数据时应该对它们同步，以避免多个线程同时修改这些数据。</li><li>如果 Servlet <strong>访问外部资源</strong>，那么需要<strong>同步访问</strong>这些资源。例如，假设 Servlet 要从文件中读写数据。当一个线程读写一个文件时，其他线程也可能正在读写这个文件。文件访问本身不是线程安全的，所以必须编写同步访问这些资源的代码。</li></ul><p><strong>在编写线程安全的 Servlet 时，下面两种方法是不应该使用的：</strong></p><ol><li><p>在 Servlet API 中提供了一个 SingleThreadModel 接口，实现这个接口的 Servlet 在被多个客户请求时一个时刻只有一个线程运行。这个接口已被标记<em>不推荐使用</em>。</p></li><li><p>对 doGet() 或doPost() 方法同步。如果必须在 Servlet 中使用同步代码 <strong>synchronized(obj){}</strong>，应尽量在最小的代码块范围上进行同步。同步代码越小，Servlet 执行得才越好。</p></li></ol><hr><h4 id="1-4、简述DefaultServlet（默认Servlet）"><a href="#1-4、简述DefaultServlet（默认Servlet）" class="headerlink" title="1.4、简述DefaultServlet（默认Servlet）"></a>1.4、简述DefaultServlet（默认Servlet）</h4><ul><li><strong>JSP/Servlet架构的web项目</strong></li></ul><p>这类项目无需显示配置DefaultSerlvet。默认情况下，jsp后缀请求会交给JspServlet，静态资源请求图片等会交给DefaultServlet处理。</p><ul><li><strong>SSM中的 DispatcherServlet 配置</strong></li></ul><pre><code>&lt;!-- Spring MVC --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;description&gt;SpringMVC&lt;/description&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!-- 启动时加载 --&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>其中，由于早期的Spring MVC不能很好地处理静态资源，所以在web.xml中配置DispatcherServlet的请求映射，往往使用 *.do 、*.action、*.xhtml等方式。（在 Controller 中的 RequestMapping 的 Value 如果是字符串没有 .do 结尾，那么 Spring MVC 会默认的加上 .do）</p><ul><li>struts早期的1版本，以.do为后缀；同时spring的MVC也是以.do为后缀。</li><li>struts2沿用了webwork2的规则，以.action为后缀。</li></ul><p>当servlet-mapping配置为*.do这类带指定后缀的时候，静态资源文件依旧可以交给DefaultServlet处理。(*.do的DispatcherServlet不会拦截类似*.jsp,*.jpg的请求)</p><p>web.xml 中配置了<code>&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</code>后，会起到两个作用：<br>（1）是限制 url 的后缀名，只能为”.do”。<br>（2）就是在没有填写后缀时，默认在你配置的 Controller 的 RequestMapping 中添加”.do”的后缀。</p><p>这种处理一般般，不够优雅😄</p><hr><p>然而，当<strong>DispatcherServlet</strong>的mapping配置为： <strong>/</strong> 的时候：</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>则Spring MVC将捕获Web容器<strong>所有的请求</strong>，包括静态资源的请求，Spring MVC会将它们当成一个普通请求处理，因此找不到对应处理器将导致错误。</p><ul><li>这时候 <strong>DispatcherServlet</strong> 会 <strong>覆盖DefaultServlet</strong> 的配置(DispathcerServlet会<strong>更先匹配</strong>到)，那么对于.jpg,.png类似这种<strong>静态资源</strong>就得不到处理（之前是defaultServlet）会处理，所以这类资源就会得到404错误。所以我们需要有额外的配置来解决这个问题。</li></ul><p><strong>方法1.继续通过DefaultServlet来处理</strong>。在应用的web.xml中将常用的静态资源URL映射到defaultServlet上。</p><pre><code>&lt;!--增加匹配范围，使得优先级比DispathcerServlet的/高--&gt;&lt;!--通过defaultServlet来处理jpg--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--通过DefaultServlet来处理png--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.png&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--通过defaultServlet来处理.js文件--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--通过defaultServlet来处理.css文件--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><hr><p><strong>方法2.采用&lt;mvc:default-servlet-handler /&gt;</strong></p><pre><code>&lt;mvc:default-servlet-handler /&gt;</code></pre><p>在 <strong>springMVC-servlet.xml</strong> 中配置<code>&lt;mvc:default-servlet-handler /&gt;</code>后，会在Spring MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，它会<strong>像一个检查员</strong>，对进入DispatcherServlet的URL进行<strong>筛查</strong>，如果发现是<strong>静态资源的请求</strong>，就将该请求<strong>转交给</strong>Web应用服务器<strong>默认的Servlet（DefaultServlet）</strong>处理，如果不是静态资源的请求，才由DispatcherServlet继续处理。</p><ul><li>一般Web应用服务器默认的Servlet名称是”default”，因此DefaultServletHttpRequestHandler可以找到它。如果使用的Web应用服务器的默认Servlet名称<strong>不是”default”</strong>，则需要通过default-servlet-name属性显示指定：</li></ul><p><code>&lt;mvc:default-servlet-handler default-servlet-name=&quot;所使用的Web服务器默认使用的Servlet名称&quot; /&gt;</code></p><hr><p><strong>方法3.采用&lt;mvc:resources /&gt;</strong></p><p><code>&lt;mvc:default-servlet-handler /&gt;</code>将静态资源的处理经由Spring MVC框架交回Web应用服务器处理。</p><p>而<code>&lt;mvc:resources /&gt;</code>更进一步，由Spring MVC框架自己处理静态资源，并添加一些有用的附加值功能。</p><ul><li><p>首先，&lt;mvc:resources /&gt;允许静态资源放在任何地方</p><ul><li>如WEB-INF目录下、类路径下等，甚至可以将JavaScript等静态文件打到JAR包中。</li><li>通过location属性指定静态资源的位置，由于location属性是Resources类型，因此可以使用诸如”classpath:”等的资源前缀指定资源位置。</li><li>传统Web容器的静态资源只能放在Web容器的根路径下，&lt;mvc:resources /&gt;完全打破了这个限制。</li></ul></li><li><p>其次，&lt;mvc:resources /&gt;依据当前著名的Page Speed、YSlow等浏览器优化原则对静态资源提供优化。</p><ul><li>可以通过cacheSeconds属性指定静态资源在浏览器端的缓存时间，一般可将该时间设置为一年，以充分利用浏览器端的缓存。</li><li>在输出静态资源时，会根据配置设置好响应报文头的Expires 和 Cache-Control值。</li><li>在接收到静态资源的获取请求时，会检查请求头的Last-Modified值，如果静态资源没有发生变化，则直接返回303相应状态码，提示客户端使用浏览器缓存的数据，而非将静态资源的内容输出到客户端，以充分节省带宽，提高程序性能。</li></ul></li></ul><p><strong>在springMVC-servlet中添加如下配置：</strong></p><pre><code>&lt;mvc:resources location=&quot;/,classpath:/META-INF/publicResources/&quot; mapping=&quot;/resources/**&quot;/&gt;</code></pre><p>以上配置将 <strong>Web根路径&quot;/&quot;</strong> 及 <strong>类路径下</strong> <strong>/META-INF/publicResources/</strong> 的目录 <strong>映射为/resources路径</strong>。</p><ul><li><p>假设Web根路径下拥有images、js这两个资源目录,在images下面有bg.gif图片，在js下面有test.js文件，则可以通过 /resources/images/bg.gif 和 /resources/js/test.js 访问这二个静态资源。</p></li><li><p>假设WebContent还拥有images/bg1.gif 及 js/test1.js，则也可以在网页中通过 /resources/images/bg1.gif 及 /resources/js/test1.js 进行引用。</p></li></ul><p><strong>也可以配置指定直接放行，将静态资源的映射进行放行：</strong></p><pre><code>&lt;!-- 放行静态资源 --&gt;&lt;!-- 放行js文件 --&gt;&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;&lt;!-- 放行css文件 --&gt;&lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;&lt;!--放行img类的资源文件--&gt;&lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt;</code></pre><hr><h3 id="二、继承HttpServlet类的方法"><a href="#二、继承HttpServlet类的方法" class="headerlink" title="二、继承HttpServlet类的方法"></a>二、继承HttpServlet类的方法</h3><p>HTTPServlet 使用一个 HTML 表单来发送和接收数据。该类是用专门的方法来处理 HTML <a href="https://baike.baidu.com/item/表单" target="_blank" rel="noopener">表单</a>的 GenericServlet 的一个子类。 HTML 表单是由 <code>&lt;form&gt;&lt;/form&gt;</code> 标记定义的。 HttpServlet 类包含 init()、destroy()、service() 等方法。其中 init() 和 destroy() 方法是继承的。</p><ul><li><strong>javax.servlet</strong> 软件包中的相关类为 <strong>ServletResponse和ServletRequest</strong>。</li><li><strong>javax.servlet.http</strong> 软件包中的相关类为 <strong>HttpServletRequest和HttpServletResponse</strong>。<ul><li>Servlet 通过这些对象与服务器通信并最终与客户端通信。</li></ul></li><li>Servlet 能通过调用”请求”对象的方法获知<strong>客户端环境</strong>，<strong>服务器环境</strong>的信息和所有由<strong>客户机发送的信息</strong>。Servlet 可以调用“响应”对象的方法<strong>发送响应</strong>，该响应是准备发回客户端的。</li></ul><h4 id="1-init-方法"><a href="#1-init-方法" class="headerlink" title="(1) init() 方法"></a>(1) init() 方法</h4><ul><li><p>在 Servlet 的生命期中，仅执行一次 init() 方法。它是在服务器装入 Servlet 时执行的。 </p></li><li><p>可以手动配置服务器，以在启动服务器或客户机首次访问 Servlet 时装入 Servlet。 无论有多少客户机访问 Servlet，都不会重复执行 init() 。</p></li><li><p>缺省 init() 方法通常是符合要求的，但也可以用定制 init() 方法来覆盖它，典型的是管理服务器端资源。 </p><ul><li>例如，可能编写一个定制 init() 来只用于一次装入 GIF 图像，改进 Servlet 返回 GIF 图像和含有多个客户机请求的性能。</li><li>另一个示例是初始化数据库连接。</li></ul></li><li><p>缺省的 init() 方法设置了 Servlet 的初始化参数，并用它的 ServletConfig 对象参数来启动配置， 因此所有覆盖 init() 方法的 Servlet 应调用 super.init() 以确保仍然执行这些任务。</p></li><li><p>在调用 service() 方法之前，应确保已完成了 init() 方法。</p></li></ul><h4 id="2-service-方法"><a href="#2-service-方法" class="headerlink" title="(2) service() 方法"></a>(2) service() 方法</h4><ul><li>service() 方法是 Servlet 的核心。每当一个客户请求一个HttpServlet 对象，该对象的service() 方法就要被调用，而且传递给这个方法一个”请求”(ServletRequest)对象和一个”响应”(ServletResponse)对象作为参数。</li><li>在 HttpServlet 中已存在 service() 方法，调用与 HTTP 请求的方法相应的 do 功能。<ul><li>例如， 如果 HTTP 请求方法为 GET，则调用 doGet() 。</li></ul></li><li>HttpServlet.service() 方法会检查请求方法是否调用了适当的处理方法，不必要覆盖 service() 方法。只需覆盖相应的 do 方法就可以了（一般都覆盖：doGet()方法、doPost()方法）。</li></ul><pre><code>//httpservlet的service()方法：protected void service(HttpServletRequest req, HttpServletResponse resp)    throws ServletException, IOException{    String method = req.getMethod();//获取请求方法    if(method.equals(&quot;GET&quot;)){        long lastModified = getLastModified(req);        if(lastModified == -1L){            doGet(req, resp);        }else{            long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);            if(ifModifiedSince &lt; (lastModified / 1000L) * 1000L){                maybeSetLastModified(resp, lastModified);                doGet(req, resp);            }else{                resp.setStatus(304);            }        }    }else if(method.equals(&quot;HEAD&quot;)){        long lastModified = getLastModified(req);        maybeSetLastModified(resp, lastModified);        doHead(req, resp);    }else if(method.equals(&quot;POST&quot;))        doPost(req, resp);    else if(method.equals(&quot;PUT&quot;))        doPut(req, resp);    else if(method.equals(&quot;DELETE&quot;))        doDelete(req, resp);    else if(method.equals(&quot;OPTIONS&quot;))        doOptions(req, resp);    else if(method.equals(&quot;TRACE&quot;)){        doTrace(req, resp);    }else{        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);        Object errArgs[] = new Object[1];        errArgs[0] = method;        errMsg = MessageFormat.format(errMsg, errArgs);        resp.sendError(501, errMsg);    }}</code></pre><p><strong>Servlet的响应可以是下列几种类型：</strong></p><p><code>response.getWriter() //输出页面</code></p><p><code>response.getOutputStream() //输出二进制流文件</code></p><p><code>request.getRequestDispatcher(&quot;target.jsp&quot;).forward(request, response) //转发</code></p><p><code>response.sendRedirect(&quot;ajax.jsp&quot;) //重定向</code></p><ul><li>关于重定向：等于客户端重新发送一个请求（新的线程，新生成的请求和响应）</li><li>关于转发：等于服务器内部跳转到别的servlet（同一线程，同一个请求和响应）</li></ul><p>一个servlet请求只能有一个响应，任何多个响应的代码都是错误的，都会出现<code>IllegalStateException</code>。也就是说，多个响应的场景是非法的。</p><h4 id="3-doGet-方法"><a href="#3-doGet-方法" class="headerlink" title="(3) doGet() 方法"></a>(3) doGet() 方法</h4><ul><li>当一个客户通过 HTML 表单发出一个 HTTP GET 请求或直接请求一个 URL 时，doGet() 方法被调用。</li><li>与 GET 请求相关的参数添加到 URL 的后面，并与这个请求一起发送。</li><li>当不会修改服务器端的数据时，应该使用 doGet() 方法。</li></ul><h4 id="4-doPost-方法"><a href="#4-doPost-方法" class="headerlink" title="(4) doPost() 方法"></a>(4) doPost() 方法</h4><ul><li>当一个客户通过 HTML 表单发出一个 HTTP POST 请求时，doPost() 方法被调用。</li><li>与 POST 请求相关的参数作为一个单独的 HTTP 请求从浏览器发送到服务器。</li><li>当需要修改服务器端的数据时，应该使用 doPost() 方法。</li></ul><h4 id="5-destroy-方法"><a href="#5-destroy-方法" class="headerlink" title="(5) destroy() 方法"></a>(5) destroy() 方法</h4><ul><li><p>destroy() 方法仅执行一次，即在服务器停止且卸装 Servlet 时执行该方法。</p><ul><li>例如：将 Servlet 作为服务器进程的一部分来关闭。</li></ul></li><li><p>缺省的 destroy() 方法通常是符合要求的，但也可以覆盖它。</p><ul><li>例如：管理服务器端资源，如果 Servlet 在运行时会累计统计数据，则可以编写一个 destroy() 方法，该方法用于在未装入 Servlet 时将统计数字保存在文件中。</li><li>另一个示例是关闭数据库连接。</li></ul></li><li><p>当服务器卸装 Servlet 时，将在所有 service() 方法调用完成后，或在指定的时间间隔过后调用 destroy() 方法。一个 Servlet 在运行 service() 方法时可能会产生其它的线程，因此请确认在调用 destroy() 方法时，这些线程已终止或完成。</p></li></ul><h4 id="6-getServletConfig-方法"><a href="#6-getServletConfig-方法" class="headerlink" title="(6) getServletConfig() 方法"></a>(6) getServletConfig() 方法</h4><p>getServletConfig() 方法返回一个 ServletConfig 对象，该对象用来返回初始化参数和 ServletContext。ServletContext 接口提供有关 servlet 的环境信息。</p><h4 id="7-getServletInfo-方法"><a href="#7-getServletInfo-方法" class="headerlink" title="(7) getServletInfo() 方法"></a>(7) getServletInfo() 方法</h4><p>getServletInfo() 方法是一个可选的方法，它提供有关 servlet 的信息，如作者、版本、版权。</p><hr><h3 id="三、HttpRequest方法"><a href="#三、HttpRequest方法" class="headerlink" title="三、HttpRequest方法"></a>三、HttpRequest方法</h3><ul><li><strong>setCharacterEncoding(编码格式)</strong></li></ul><p><code>request.setCharacterEncoding(&quot;utf-8&quot;); //设置请求编码格式</code></p><p><code>response.setCharacterEncoding(&quot;utf-8&quot;) //设置响应编码格式;</code></p><ul><li><strong>getParameter(String</strong> <strong>key)</strong>  <strong>返回一个字符串</strong><ul><li>获得name和key一样的表单空间的数据，如果name有重复，则返回的是第一个找到的name属性的数据</li></ul></li></ul><p><code>通过getParameter获取到请求链中的name属性对应第一个value值</code>  </p><p><code>String uname = request.getParameter(&quot;name&quot;);  System.*out*.println(&quot;用户名为：&quot;+uname);</code> </p><ul><li><strong>getParameterValues(String</strong> <strong>key)</strong>  <strong>返回一个字符串的数组</strong><ul><li>获得name和key一样的表单控件的数据，但是相同name控件会有多个（返回所有的name数据）；</li></ul></li></ul><pre><code>//通过getParameterValues获取到请求链中的name属性对应的一组value值    String[] hobby =  request.getParameterValues(&quot;hobby&quot;);System.out.print(&quot;爱好为：&quot;);for(String str:hobby){    System.out.print(str+&quot;,&quot;);}System.out.println();</code></pre><ul><li><strong>getParameterMap()</strong>  <strong>返回一个包含所有参数的map</strong><ul><li>key-String[]模式，即key是表单控件的name，同时，为防止有重复的name的控件存在，每个name对应一个字符串数据 </li></ul></li></ul><pre><code>//通过getParameterMap获取到整个form表单数据Map&lt;String, String[]&gt; form = request.getParameterMap();//通过key获取到整个表单的name属性Set&lt;String&gt; names = form.keySet();for(String str:names){    System.out.print(str+&quot;:&quot;);    String[] values = form.get(str);    String value = &quot;&quot;;    for(String val:values){        value += val+&quot;,&quot;;    }        System.out.println( value.substring(0,value.length()-1) );}  </code></pre><ul><li><p>setcharacterEncoding(): 设置请求通道编码格式</p></li><li><p>getRemoteAddr()：返回客户端的IP地址</p></li><li><p>getContentType()：获得请求正文的MIME类型</p></li><li><p>getContextPath()：返回客户端所请求访问的Web应用的URL入口</p></li><li><p>getMethod()：返回Http请求方式</p></li><li><p>getRequestDispatcher() :转发到指定地址并使用forward跳转</p></li></ul><h3 id="四、HttpServletResponse方法"><a href="#四、HttpServletResponse方法" class="headerlink" title="四、HttpServletResponse方法"></a>四、HttpServletResponse方法</h3><ul><li><p>setCharacterEncoding(): 设置响应通道编码格式</p></li><li><p>setContentType(String type)：设置响应正文的MIME类型</p></li><li><p>getCharacterEncoding()：返回响应正文的字符编码</p></li><li><p>getContentType()：返回响应正文的MIME类型。</p></li><li><p>sendRedirect() 用于响应重定向</p></li></ul><p>在用户浏览器工作中，sendRedirect()可以带参数传递，比如    response.sendRedirect(“welcome?acount=”+account+”&amp;password=”+password)，传递    至下一个页面，同时它可以重新指向另一个页面</p><p>注：1.welcome代表你要重定向的那个Servlet的url</p><p>​        2.Servlet url名和变量之间有？连接</p><p>​        3.如果要传递两个或以上参数，参数之间用&amp;连接</p><hr><h3 id="五、request-getRequestURL-和request-getRequestURI-的区别"><a href="#五、request-getRequestURL-和request-getRequestURI-的区别" class="headerlink" title="五、request.getRequestURL()和request.getRequestURI()的区别"></a>五、request.getRequestURL()和request.getRequestURI()的区别</h3><ul><li><p>request.getRequestURL() 返回 <strong>全路径</strong></p><ul><li>如：<a href="http://localhost:8080/myServlet/page/index.jsp" target="_blank" rel="noopener">http://localhost:8080/myServlet/page/index.jsp</a></li></ul></li><li><p>request.getRequestURI() 返回 <strong>除去host（域名或者ip）部分的路径</strong></p><ul><li>如：/myServlet/page/index.jsp</li></ul></li><li><p>request.getContextPath() 返回 <strong>工程名部分</strong>，如果工程映射为/，此处返回则为空</p><ul><li>如：/myServlet</li></ul></li><li><p>request.getServletPath() 返回 <strong>除去host和工程名部分的路径</strong></p><ul><li>如：/page/index.jsp</li></ul></li></ul><p><strong>注：myServlet为工程名、page为WebContext下的目录名</strong></p><hr><h3 id="六、getInitParameter方法-从web-xml中获取参数"><a href="#六、getInitParameter方法-从web-xml中获取参数" class="headerlink" title="六、getInitParameter方法(从web.xml中获取参数)"></a>六、getInitParameter方法(从web.xml中获取参数)</h3><p>在 <strong>ServletConfig</strong> 和 <strong>ServletContext</strong> 都有 getInitParameter 方法， </p><p>这两个方法的都能从web.xml中获取参数，但是是有区别的。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;web-app id=&quot;WebApp_ID&quot; version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;      &lt;context-param&gt;        &lt;param-name&gt;webParam&lt;/param-name&gt;        &lt;param-value&gt;bigbigbig&lt;/param-value&gt;      &lt;/context-param&gt;      &lt;servlet&gt;          &lt;servlet-name&gt;test&lt;/servlet-name&gt;          &lt;servlet-class&gt;com.wenah.Test&lt;/servlet-class&gt;          &lt;init-param&gt;            &lt;param-name&gt;servletParam&lt;/param-name&gt;            &lt;param-value&gt;smallsmallsmall&lt;/param-value&gt;          &lt;/init-param&gt;      &lt;/servlet&gt;      &lt;servlet-mapping&gt;          &lt;servlet-name&gt;test&lt;/servlet-name&gt;          &lt;url-pattern&gt;/testParam&lt;/url-pattern&gt;      &lt;/servlet-mapping&gt;  &lt;/web-app&gt;  </code></pre><p>测试类：</p><pre><code>@WebServlet(&quot;/testParam&quot;)public class Test extends HttpServlet {    public void doGet(HttpServletRequest request, HttpServletResponse response)              throws ServletException, IOException {        //独属于Test这个Servlet的参数:        String sParam = this.getInitParameter(&quot;servletParam&quot;);        //web范围的参数:        String wParam = this.getServletContext().getInitParameter(&quot;webParam&quot;);          String ret = &quot;{Test}sParam:&quot;+sParam+&quot;&lt;br/&gt;{Test}wParam:&quot;+wParam;        resp.getWriter().write(ret);    }  }  </code></pre><p>输出结果：</p><p>{Test}sParam:smallsmallsmall</p><p>{Test}wParam:bigbigbig</p><hr><h3 id="七、Filter过滤器"><a href="#七、Filter过滤器" class="headerlink" title="七、Filter过滤器"></a>七、Filter过滤器</h3><ul><li>Filter过滤器是servlet和jsp的核心技术</li><li>可以统一的去控制资源，统一处理问题，对于<strong>权限的控制</strong>，可以大大的提高开发的效率，高复用部分代码。</li></ul><h4 id="5-1、实现的接口为servlet-filter接口"><a href="#5-1、实现的接口为servlet-filter接口" class="headerlink" title="5.1、实现的接口为servlet.filter接口"></a>5.1、实现的接口为servlet.filter接口</h4><ol><li>当客户端发送请求后，servlet容器会调用filter过滤器</li><li>如果请求在filter中<strong>通过</strong>，则会将请求转发给servlet</li><li>如果请求在filer中<strong>不通过</strong>，则进行指定跳转</li></ol><p><strong>Filter中需要实现的方法：</strong></p><ul><li>Init方法</li><li>doFilter方法</li><li>destroy 方法</li></ul><hr><h4 id="5-2、创建字符编码过滤器（解决中文乱码问题）"><a href="#5-2、创建字符编码过滤器（解决中文乱码问题）" class="headerlink" title="5.2、创建字符编码过滤器（解决中文乱码问题）"></a>5.2、创建字符编码过滤器（解决中文乱码问题）</h4><p>需要实现filter接口：</p><pre><code>public class EncodingFilter implements Filter {    //定义一个变量，用于接收配置文件中的初始属性    String encoding = &quot;&quot;;    @Override    public void destroy() {        // TODO Auto-generated method stub    }    @Override    public void doFilter(ServletRequest arg0, ServletResponse arg1,            FilterChain filterChain) throws IOException, ServletException {        //因为filter中使用的请求与响应都不携带Http协议，需要先将请求与响应强转为http协议的请求与响应        HttpServletRequest request = (HttpServletRequest) arg0;        HttpServletResponse response = (HttpServletResponse) arg1;        //当filter中统一设置编码格式后，其他的类都不需要设置编码格式        request.setCharacterEncoding(encoding);        response.setCharacterEncoding(encoding);        response.setContentType(&quot;text/html;charset=utf-8&quot;);        //让过滤器将执行后的请求与响应再次回到请求链中        filterChain.doFilter(request, response);    }    @Override    public void init(FilterConfig config) throws ServletException {        //getInitParameter()从web.xml中获取对应的参数        encoding = config.getInitParameter(&quot;encoding&quot;);    }}</code></pre><p><strong>配置web.xml文件</strong>，使指定请求进入到filter过滤器中</p><pre><code>&lt;!-- 设置一对filter映射关系 --&gt;&lt;filter&gt;    &lt;filter-name&gt;encod&lt;/filter-name&gt;    &lt;filter-class&gt;com.entor.filter.EncodingFilter&lt;/filter-class&gt;    &lt;!-- 为过滤器设置一个初始属性，在过滤器中的init方法获取 --&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encod&lt;/filter-name&gt;    &lt;!-- /*表示所有的请求都会进入过滤器 --&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><hr><h4 id="5-3、登录权限控制"><a href="#5-3、登录权限控制" class="headerlink" title="5.3、登录权限控制"></a>5.3、登录权限控制</h4><pre><code>public class UsersFilter implements Filter {    //定义可放行的请求    String[] urls = {&quot;/login&quot;,&quot;/loginServlet&quot;};    @Override    public void destroy() {}    @Override    public void doFilter(ServletRequest arg0, ServletResponse arg1,            FilterChain chain) throws IOException, ServletException {        HttpServletRequest request = (HttpServletRequest) arg0;        HttpServletResponse response = (HttpServletResponse) arg1;        boolean flag = false;        //获取到请求的相对路径        String path = request.getRequestURI();        for(String url:urls){    //遍历验证可放行的请求            if(path.indexOf(url)!=-1){                flag = true;                break;            }        }        if(flag){            chain.doFilter(request, response); //可放行的请求,执行放行操作        }else{            //判断session是否为空，session都为空一定是非登录状态            //getSession(false)：false表示获取对象而非创建session对象            if(request.getSession(false)!=null){                //从session中获取到user对象                Users user = (Users) request.getSession(false).getAttribute(&quot;user&quot;);                if(user!=null){                    //如果都验证成功，回到请求链                    chain.doFilter(request, response);    //已登陆用户,执行放行操作                }            }            //如果不成功则重定向到login界面(也可自定义失败页面)            response.sendRedirect(&quot;login&quot;);        }    }    @Override    public void init(FilterConfig arg0) throws ServletException {        // TODO Auto-generated method stub    }}</code></pre><p>配置权限控制过滤器的web.xml</p><pre><code>&lt;!-- 设置一对filter映射关系 --&gt;&lt;filter&gt;    &lt;filter-name&gt;userFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.entor.filter.UsersFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;userFilter&lt;/filter-name&gt;    &lt;!-- /*表示所有的请求都会进入过滤器 --&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>越写越多了，w(ﾟДﾟ)w</p><hr><blockquote><p><a href="https://baike.baidu.com/item/servlet" target="_blank" rel="noopener">百度百科|Servlet</a></p><p><a href="https://blog.csdn.net/qq_30920821/java/article/details/78328608" target="_blank" rel="noopener">Web容器中DefaultServlet详解</a></p><p><a href="https://blog.csdn.net/javadxz/article/details/6400448" target="_blank" rel="noopener">servlet doPost() doHead() doGet()等方法被执行的由来</a></p><p><a href="https://www.cnblogs.com/dflmg/p/6393416.html" target="_blank" rel="noopener">【Spring框架】<a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a>的作用</a></p><p><a href="https://blog.csdn.net/gavid0124/java/article/details/45390999" target="_blank" rel="noopener">request.getRequestURL()和request.getRequestURI()的区别</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
            <tag> 基础 </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro系统安全框架</title>
      <link href="/2020/07/16/shiro-ji-chu/"/>
      <url>/2020/07/16/shiro-ji-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Shiro介绍"><a href="#一、Shiro介绍" class="headerlink" title="一、Shiro介绍"></a>一、Shiro介绍</h3><h4 id="1-1、-Shiro是什么？"><a href="#1-1、-Shiro是什么？" class="headerlink" title="1.1、 Shiro是什么？"></a>1.1、 Shiro是什么？</h4><ul><li>Apache Shiro 是 Java 的一个安全框架</li><li>为应用系统设一道屏障，防止有人恶意入侵</li><li>维护系统登陆与权限控制</li><li>轻量级框架（JaveSE环境、JavaEE环境都可用）</li></ul><hr><h4 id="1-2、-Shiro主要用在哪里？"><a href="#1-2、-Shiro主要用在哪里？" class="headerlink" title="1.2、 Shiro主要用在哪里？"></a>1.2、 Shiro主要用在哪里？</h4><ul><li><p>处理系统用户的身份认证（验证一个人的身份，是否同一人）</p><ul><li>传统的身份验证：如用户登录，输入用户名 + 密码，再判断用户名与密码的信息。（简单、不够安全）</li><li>Shiro：有一整套身份认证策略，还有其他辅助功能。提供了其他的安全保障、嗨提供了密码加密处理功能（MD5）</li></ul></li><li><p>权限的授权</p></li><li><p>会话管理方面的事务</p></li></ul><hr><h4 id="1-3、-Shiro基本功能"><a href="#1-3、-Shiro基本功能" class="headerlink" title="1.3、 Shiro基本功能"></a>1.3、 Shiro基本功能</h4><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/image-20200716101830536.png" style="zoom: 33%;" /><ol><li>Authentication<ul><li>身份认证/登陆。</li><li>验证用户是不是拥有相应的身份。</li></ul></li><li>Authorization<ul><li>授权（权限认证）。</li><li>验证某个已认证的用户是否拥有某个权限。<ul><li>粗粒度：按觉得划分，验证某个用户是否拥有某个角色（能操作哪些内容）。</li><li>细粒度：按资源划分，验证某个用户对<strong>某个资源</strong>是否拥有<strong>权限</strong>。</li></ul></li></ul></li><li>Session Manager<ul><li>用户登陆后，退出之前，它的所有信息都在会话中。</li><li>会话可以在普通 <strong>JavaSE</strong> 环境，也可以是 <strong>Web</strong> 环境。</li></ul></li><li>Cryptography<ul><li>加密，主要是指保护数据的安全性。</li><li>比如：密码<strong>加密</strong>后存储到数据库，而不是<strong>明文存储</strong>。<ul><li>明文保存有重大隐患（泄露、非法入侵者、非法操作的工作人员等可直接获取）</li></ul></li></ul></li></ol><hr><h3 id="二、Shiro的执行"><a href="#二、Shiro的执行" class="headerlink" title="二、Shiro的执行"></a>二、Shiro的执行</h3><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/image-20200716133326220.png" style="zoom:50%;" /><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/image-20200716141233462.png" style="zoom: 50%;" /><ul><li>应用启动后</li><li>当前用户进入（比如调用 login() 方法）</li><li>首先会经过 <strong>Shiro</strong> <strong>SecurityManager</strong> 安全管理器</li><li>通过 <strong>Realm</strong> 访问安全数据<ul><li>比如登陆：获取数据库的用户名与密码，提供给验证器验证。</li><li>比如用户某个操作的权限管理：获取用户权限数据，提供验证器验证。</li></ul></li></ul><hr><h3 id="三、常见-API-对象"><a href="#三、常见-API-对象" class="headerlink" title="三、常见 API 对象"></a>三、常见 API 对象</h3><h4 id="3-1、Subject"><a href="#3-1、Subject" class="headerlink" title="3.1、Subject"></a>3.1、Subject</h4><ul><li><p>概念描述</p><ul><li><p>主体，代表了当前“用户”，这个用户不一定是一个具体的人。</p></li><li><p>与当前应用交互的任何东西都是Subject，如：网络爬虫、机器人等。</p></li></ul></li><li><p>与 Subject 的所有交互都会委托给 SecurityManager 处理</p><ul><li>Subject调用方法执行，底层代码实现交给 SecurityManager 。</li></ul></li></ul><h4 id="3-2、SecurityManager"><a href="#3-2、SecurityManager" class="headerlink" title="3.2、SecurityManager"></a>3.2、SecurityManager</h4><ul><li>安全管理器，即所有与安全有关的操作都会与 SecurityManager  交互。</li><li>管理着所有的 Subject 主体。</li><li>Shiro 的核心，负责与后面介绍的其他组件进行交互，可把它看作 ”控制器“。</li></ul><h4 id="3-3、Realm（翻译：n-领域-场所-王国）"><a href="#3-3、Realm（翻译：n-领域-场所-王国）" class="headerlink" title="3.3、Realm（翻译：n.领域;场所;王国）"></a>3.3、Realm（翻译：n.领域;场所;王国）</h4><ul><li>域，Shiro 从 Realm 获取 “安全数据” （如：用户、角色、权限）</li><li>即是 SecurityManager 要验证用户身份时，它需要冲 Realm 获取相应的用户进行<strong>比较</strong>，以确定用户身份是否合法。也需要从 Realm 得到用户相应的 <strong>角色/权限</strong> 进行验证用户是否能进行操作。</li><li>可以把 Realm 看成 DataSource，即<strong>安全数据源</strong>。</li></ul><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/image-20200716141657352.png" style="zoom:50%;" /><hr><h3 id="四、Shiro的内部结构"><a href="#四、Shiro的内部结构" class="headerlink" title="四、Shiro的内部结构"></a>四、Shiro的内部结构</h3><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/ShiroInner.png" style="zoom: 80%;" /><ul><li>Realm可插拔，各个Realm有对应的数据库。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
            <tag> Shiro </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基础</title>
      <link href="/2020/07/10/http-bi-ji/"/>
      <url>/2020/07/10/http-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="1、HTTP简介"><a href="#1、HTTP简介" class="headerlink" title="1、HTTP简介"></a>1、HTTP简介</h3><h4 id="1-1、-HTTP是什么？"><a href="#1-1、-HTTP是什么？" class="headerlink" title="1.1、 HTTP是什么？"></a>1.1、 HTTP是什么？</h4><ol><li><p>HTTP协议是 <strong>Hyper Text Transfer Protocol</strong>（超文本传输协议）的缩写。</p></li><li><p>是用于万维网（WWW:World Wide Web）传输超文本的传送协议，规定WWW服务器与浏览器之间信息传递规范。（HTTP协议 <strong>永远都是</strong> 客户端发起请求，服务器回送响应）</p></li><li><p>HTTP基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等），默认端口号为80。</p></li></ol><h4 id="1-2、-三个特性"><a href="#1-2、-三个特性" class="headerlink" title="1.2、 三个特性"></a>1.2、 三个特性</h4><ul><li>HTTP是无连接的：每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。（连接是有限的，并且及时地释放连接提高服务器的执行效率）</li><li>HTTP是媒体独立的：只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。（MIME-type：如Content-Type: text/HTML）</li><li>HTTP是无状态：无状态协议，即服务器不保留与客户交易时的任何状态。同一个客户端的这次请求和上次请求是没有对应关系。这就大大减轻了服务器记忆负担，从而保持较快的响应速度。</li></ul><h4 id="1-3、-MIME-type-是什么？"><a href="#1-3、-MIME-type-是什么？" class="headerlink" title="1.3、 MIME-type 是什么？"></a>1.3、 MIME-type 是什么？</h4><ul><li><p>MIME (<strong>M</strong>ultipurpose <strong>I</strong>nternet <strong>M</strong>ail <strong>E</strong>xtensions) —— 描述消息内容类型的因特网标准。</p></li><li><p>也就是资源的媒体类型，通常只有一些在互联网上获得广泛应用的格式才会获得一个 MIME Type。</p></li><li><p>如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。</p></li></ul><p><strong>每个MIME类型由两部分组成：</strong></p><ol><li><p>前面是数据的大类别，例如声音audio、图象image等</p></li><li><p>后面定义具体的种类。</p></li></ol><p><strong>常见的MIME类型：</strong></p><ul><li>超文本标记语言文本 .htm、.html   ——  <strong>text/html</strong> </li><li>普通文本 .txt   ——  <strong>text/plain</strong></li><li>RTF文本 .rtf   ——  <strong>application/rtf</strong></li><li>GIF图形 .gif   ——  <strong>image/gif</strong> </li><li>JPEG图形 .ipeg、.jpg   ——  <strong>image/jpeg</strong></li><li>au声音文件 .au   ——  <strong>audio/basic</strong></li><li>MIDI音乐文件 mid、.midi   ——  <strong>audio/midi</strong></li><li>RealAudio音乐文件 .ra、.ram   ——  <strong>audio/x-pn-realaudio</strong> </li><li>MPEG文件 .mpg、.mpeg   ——  <strong>video/mpeg</strong> </li><li>AVI文件 .avi   ——  <strong>video/x-msvideo</strong> </li><li>GZIP文件 .gz   ——  <strong>application/x-gzip</strong> </li><li>TAR文件 .tar   ——  <strong>application/x-tar</strong> </li></ul><h4 id="1-4、-HTTP的工作原理"><a href="#1-4、-HTTP的工作原理" class="headerlink" title="1.4、 HTTP的工作原理"></a>1.4、 HTTP的工作原理</h4><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><p>（1）客户与服务器建立连接（开始一个链接，如点击 &lt;a href=&quot;<a href="https://coderuan.cn&quot;" target="_blank" rel="noopener">https://coderuan.cn&quot;</a> /&gt;wenah阮&lt;/a&gt; 标签）</p><p>（2）客户向服务器提出请求（格式为：请求行、请求头部、空行和请求数据四个部分组成）</p><p>（3）服务器接受请求，并根据请求返回相应的应答（分别是：状态行、消息报头、空行和响应正文）</p><p>（4）客户与服务器关闭连接</p><ul><li>客户与服务器之间的HTTP连接是一种一次性连接，它限制每次连接只处理一个请求，当服务器返回本次请求的应答后便立即关闭连接，下次请求再重新建立连接。</li><li>这种一次性连接主要考虑到WWW服务器面向的是Internet中成干上万个用户，且只能提供有限个连接，故服务器不会让一个连接处于等待状态，及时地释放连接可以大大提高服务器的执行效率。</li></ul><hr><h3 id="2、HTTP请求方法（9种）"><a href="#2、HTTP请求方法（9种）" class="headerlink" title="2、HTTP请求方法（9种）"></a>2、HTTP请求方法（9种）</h3><ul><li><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法（常用的请求方法是GET和POST）</p></li><li><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p></li></ul><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h4 id="2-1、GET和POST方法区别"><a href="#2-1、GET和POST方法区别" class="headerlink" title="2.1、GET和POST方法区别"></a>2.1、GET和POST方法区别</h4><ol><li><p><strong>使用方式</strong>：GET是从服务器上获取数据；POST是向服务器传送数据。</p></li><li><p><strong>提交方式</strong>：在客户端，GET通过URL提交数据，数据在URL中可见；POST把数据放在form的数据体内提交。</p></li><li><p><strong>数据容量</strong>：GET提交的数据最多只有1024字节；POST提交的数据量无限制。</p></li><li><p><strong>数据安全</strong>：使用 GET 参数会显示在地址栏上，而 POST 不会，所以如果包含<strong>敏感数据</strong>，为了安全，用POST。</p></li></ol><table><thead><tr><th align="left"></th><th align="left">GET</th><th align="left">POST</th></tr></thead><tbody><tr><td align="left">后退按钮/刷新</td><td align="left">无害</td><td align="left">数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td align="left">书签</td><td align="left">可收藏为书签</td><td align="left">不可收藏为书签</td></tr><tr><td align="left">缓存</td><td align="left">能被缓存</td><td align="left">不能缓存</td></tr><tr><td align="left">编码类型</td><td align="left">application/x-www-form-urlencoded</td><td align="left">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td align="left">历史</td><td align="left">参数保留在浏览器历史中。</td><td align="left">参数不会保存在浏览器历史中。</td></tr><tr><td align="left">对数据长度的限制</td><td align="left">当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td align="left">无限制。</td></tr><tr><td align="left">对数据类型的限制</td><td align="left">只允许 ASCII 字符。</td><td align="left">没有限制。也允许二进制数据。</td></tr><tr><td align="left">安全性</td><td align="left">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td align="left">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td align="left">可见性</td><td align="left">数据在 URL 中对所有人都是可见的。</td><td align="left">数据不会显示在 URL 中。</td></tr></tbody></table><h4 id="2-2、何时使用GET？"><a href="#2-2、何时使用GET？" class="headerlink" title="2.2、何时使用GET？"></a>2.2、何时使用GET？</h4><p>检索信息时一般用GET方法，如检索文档、图表、或数据库查询结果。要检索的信息作为字符序列传递，称为查询字符串。GET方法是表单默认的方法。</p><p>GET 请求的查询字符串（名称/值对）是在 URL 中发送的：</p><p><code>/test/demo_form.asp?name1=value1&amp;name2=value2</code></p><p>有关 GET 请求的其他一些注释：</p><ul><li>GET 请求可被缓存</li><li>GET 请求保留在浏览器历史记录中</li><li>GET 请求可被收藏为书签</li><li>GET 请求不应在处理敏感数据时使用</li><li>GET 请求有长度限制</li><li>GET 请求只应当用于取回数据</li></ul><h4 id="2-3、何时使用POST"><a href="#2-3、何时使用POST" class="headerlink" title="2.3、何时使用POST"></a>2.3、何时使用POST</h4><p>POST 请求的查询字符串（名称/值对）是在 HTTP 消息主体中发送的：</p><pre><code>POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2</code></pre><p>有关 POST 请求的其他一些注释：</p><ul><li>POST 请求不会被缓存</li><li>POST 请求不会保留在浏览器历史记录中</li><li>POST 不能被收藏为书签</li><li>POST 请求对数据长度没有要求</li></ul><hr><h3 id="3、HTTP状态码"><a href="#3、HTTP状态码" class="headerlink" title="3、HTTP状态码"></a>3、HTTP状态码</h3><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。</p><p>HTTP状态码共分为5种类型：</p><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息 —— 服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功 —— 操作被成功接收并处理（如200：请求成功，其后是对GET和POST请求的应答文档）</td></tr><tr><td align="left">3**</td><td align="left">重定向 —— 需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误 —— 请求包含语法错误或无法完成请求（如400：Bad Request 服务器未能理解请求、404：Not Found 服务器无法找到被请求的页面。）</td></tr><tr><td align="left">5**</td><td align="left">服务器错误 —— 服务器在处理请求的过程中发生了错误（如500：Internal Server Error内部服务器错误，请求未完成。服务器遇到不可预知的情况。）</td></tr></tbody></table><hr><h3 id="4、-什么是HTTPS"><a href="#4、-什么是HTTPS" class="headerlink" title="4、 什么是HTTPS"></a>4、 什么是HTTPS</h3><ul><li><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是<strong>以安全为目标</strong>的HTTP通道。</p></li><li><p>简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。</p></li></ul><p><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/HTTPS.jpg" alt="图解" title="图解"></p><p>有两种基本的加解密算法类型：</p><ol><li><p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</p></li><li><p>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p></li></ol><p><strong>https通信的优点：</strong></p><ul><li>客户端产生的密钥只有客户端和服务器端能得到</li><li>加密的数据只有客户端和服务器端才能得到明文</li><li>客户端到服务端的通信是安全的。</li></ul><hr><blockquote><p><a href="https://baike.baidu.com/item/HTTP/243074" target="_blank" rel="noopener">百度百科 HTTP</a></p><p><a href="https://www.runoob.com/http/http-tutorial.html" target="_blank" rel="noopener">菜鸟教程|HTTP</a></p><p><a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">W3school|HTTP</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组查找特定组合</title>
      <link href="/2020/07/09/er-wei-shu-zu-cha-zhao-te-ding-zu-he/"/>
      <url>/2020/07/09/er-wei-shu-zu-cha-zhao-te-ding-zu-he/</url>
      
        <content type="html"><![CDATA[<h3 id="舍友面试看见的一道算法题"><a href="#舍友面试看见的一道算法题" class="headerlink" title="舍友面试看见的一道算法题"></a>舍友面试看见的一道算法题</h3><p><img src="https://tencentcloud-1302662658.cos.ap-guangzhou.myqcloud.com/medias/wordsArray.png" alt="题目" title="就这！做了半天！"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Count</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//定义要查询的查询组合</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> apple <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//记录查询的下标</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//记录次数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//题目要求查询的二维数组</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> <span class="token punctuation">{</span>                <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'h'</span><span class="token punctuation">,</span><span class="token string">'x'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span><span class="token string">'i'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//开始查找</span>        <span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.首先遍历所有,找出a</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> c<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>apple<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 2.从a开始,遍历周围,查找下一个目标字符</span>                    <span class="token function">findChar</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>apple<span class="token punctuation">[</span><span class="token operator">++</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//每次查找完a,清空下标</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------- 一个'a'查找完毕 -----------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"总次数："</span><span class="token operator">+</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//定义找到的 apple[index] 字符坐标为 (xEnd,yEnd)</span>    <span class="token comment" spellcheck="true">//它的上一个坐标为 (xStart,yStart) ————>防止重复查找</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">findChar</span><span class="token punctuation">(</span><span class="token keyword">int</span> xStart<span class="token punctuation">,</span> <span class="token keyword">int</span> yStart<span class="token punctuation">,</span><span class="token keyword">int</span> xEnd<span class="token punctuation">,</span><span class="token keyword">int</span> yEnd<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">,</span><span class="token keyword">char</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>xEnd<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1、在第一行</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>xEnd<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token punctuation">(</span>xEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本行以及下一行</span>                <span class="token function">loopY</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span>yStart<span class="token punctuation">,</span>xEnd<span class="token punctuation">,</span> yEnd<span class="token punctuation">,</span> i<span class="token punctuation">,</span> c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> xEnd<span class="token operator">==</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//2、在最后行</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token punctuation">(</span>xEnd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>xEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本行以及上一行</span>                <span class="token function">loopY</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span>yStart<span class="token punctuation">,</span>xEnd<span class="token punctuation">,</span> yEnd<span class="token punctuation">,</span> i<span class="token punctuation">,</span> c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//3、在中间行</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token punctuation">(</span>xEnd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token punctuation">(</span>xEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本行及上下两行</span>                <span class="token function">loopY</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span>yStart<span class="token punctuation">,</span>xEnd<span class="token punctuation">,</span> yEnd<span class="token punctuation">,</span> i<span class="token punctuation">,</span> c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//判断列的位置是否在边缘，然后分情况循环查询</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loopY</span><span class="token punctuation">(</span><span class="token keyword">int</span> xStart<span class="token punctuation">,</span> <span class="token keyword">int</span> yStart<span class="token punctuation">,</span><span class="token keyword">int</span> xEnd<span class="token punctuation">,</span> <span class="token keyword">int</span> yEnd<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">,</span><span class="token keyword">char</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>yEnd<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//在第一列</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> yEnd<span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token punctuation">(</span>yEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本列以及右一列</span>                <span class="token function">check</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span> yStart<span class="token punctuation">,</span> xEnd<span class="token punctuation">,</span>yEnd<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//符合条件，下一轮寻找</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> yEnd<span class="token operator">==</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>xEnd<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//在最后列</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>yEnd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>yEnd <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本列以及左一列</span>                <span class="token function">check</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span> yStart<span class="token punctuation">,</span> xEnd<span class="token punctuation">,</span>yEnd<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//符合条件，下一轮寻找</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//在中间列</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>yEnd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token punctuation">(</span>yEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历本列，及左右列</span>                <span class="token function">check</span><span class="token punctuation">(</span>xStart<span class="token punctuation">,</span> yStart<span class="token punctuation">,</span> xEnd<span class="token punctuation">,</span>yEnd<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//符合条件，下一轮寻找</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//开始检验，符合条件回调继续查询</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span> xStart<span class="token punctuation">,</span> <span class="token keyword">int</span> yStart<span class="token punctuation">,</span><span class="token keyword">int</span> xEnd<span class="token punctuation">,</span> <span class="token keyword">int</span> yEnd<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">,</span><span class="token keyword">char</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>xStart<span class="token operator">==</span>i <span class="token operator">&amp;&amp;</span> yStart<span class="token operator">==</span>j<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//排除上一个点</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>xEnd<span class="token operator">==</span>i <span class="token operator">&amp;&amp;</span> yEnd<span class="token operator">==</span>j<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//排除自身</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[debug]从第%d行,第%d列————>找到 第%d行,第%d列: %c 字母.\n"</span><span class="token punctuation">,</span>                    <span class="token punctuation">(</span>xEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>yEnd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> apple<span class="token punctuation">[</span>apple<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//找到目标</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[debug]第%d次找到目标e\n"</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                num<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//计数加一</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">findChar</span><span class="token punctuation">(</span>xEnd<span class="token punctuation">,</span>yEnd<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>c<span class="token punctuation">,</span>apple<span class="token punctuation">[</span><span class="token operator">++</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//符合条件，下一轮寻找</span>            <span class="token operator">--</span>index<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//找完之后，回到上一个节点，继续找</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="程序结果："><a href="#程序结果：" class="headerlink" title="程序结果："></a>程序结果：</h3><p>[debug]从第1行,第1列————&gt;找到 第1行,第2列: p 字母.<br>[debug]从第1行,第2列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第1次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第2次找到目标e<br>[debug]从第1行,第2列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第3次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第4次找到目标e<br>[debug]从第1行,第1列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第1行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第5次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第6次找到目标e<br>[debug]从第2行,第2列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第7次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第8次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第4行,第2列: l 字母.<br>[debug]从第4行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第9次找到目标e<br>[debug]从第4行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第10次找到目标e<br>———- 一个’a’查找完毕 ———–<br>[debug]从第2行,第4列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第1行,第2列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第11次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第12次找到目标e<br>[debug]从第2行,第3列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第13次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第14次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第4行,第2列: l 字母.<br>[debug]从第4行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第15次找到目标e<br>[debug]从第4行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第16次找到目标e<br>[debug]从第2行,第4列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第17次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第18次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第19次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第20次找到目标e<br>——— 一个’a’查找完毕 ———–<br>[debug]从第3行,第4列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第1行,第2列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第21次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第22次找到目标e<br>[debug]从第2行,第3列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第23次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第24次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第4行,第2列: l 字母.<br>[debug]从第4行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第25次找到目标e<br>[debug]从第4行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第26次找到目标e<br>[debug]从第3行,第4列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第27次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第28次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第29次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第30次找到目标e<br>——— 一个’a’查找完毕 ———–<br>[debug]从第4行,第4列————&gt;找到 第3行,第3列: p 字母.<br>[debug]从第3行,第3列————&gt;找到 第2行,第2列: p 字母.<br>[debug]从第2行,第2列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第31次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第32次找到目标e<br>[debug]从第3行,第3列————&gt;找到 第2行,第3列: p 字母.<br>[debug]从第2行,第3列————&gt;找到 第3行,第2列: l 字母.<br>[debug]从第3行,第2列————&gt;找到 第3行,第1列: e 字母.<br>[debug]第33次找到目标e<br>[debug]从第3行,第2列————&gt;找到 第4行,第1列: e 字母.<br>[debug]第34次找到目标e<br>——— 一个’a’查找完毕 ———–<br>总次数：34</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>不能空想，要模仿计算机，写出执行步骤，判断逻辑。</li><li>可别再复制黏贴了，就一个 x 和 y 写混了，改了一早上，佛了。</li><li>多写注释，不然过了一晚上，自己的代码都看懵了。</li></ul><hr><p>其实本次实现还不够完善，因为字符里面只有2个 ‘p’ 是重复的，偷懒省去了很多判断。</p><p>上面的代码只取了上一个节点的坐标，保证2个 ‘p’ 没有重复，没有判断的5个点的坐标。</p><hr><h6 id="嘤嘤嘤"><a href="#嘤嘤嘤" class="headerlink" title="嘤嘤嘤"></a>嘤嘤嘤</h6>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2020/07/07/java-yu-yan-gai-shu/"/>
      <url>/2020/07/07/java-yu-yan-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h2><h4 id="一、Java不同开发版本"><a href="#一、Java不同开发版本" class="headerlink" title="一、Java不同开发版本"></a>一、Java不同开发版本</h4><ul><li>JavaSE：Java Standard Edition —— 基础的控制台程序，桌面应用。</li><li>JavaME：Java Micro Edition (缩小版) —— 电子词典程序，pda软件，机顶盒软件……</li><li>JavaEE：Java Enterprise Edition (企业版) —— Web网站(如：淘宝、京东)。</li></ul><h4 id="二、Java特点与特性"><a href="#二、Java特点与特性" class="headerlink" title="二、Java特点与特性"></a>二、Java特点与特性</h4><h4 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h4><ul><li>简单易用：<ul><li>深层封装语言, 屏蔽很多底层细节, 提供很多工具库。<br>没有指针 (不直接操作内存数据, 不能操作寄存器)。<br>有垃圾回收机制, 帮我们处理内存垃圾数据。</li></ul></li><li>面向对象</li><li>可移植性</li></ul><h4 id="2-2-三大特性"><a href="#2-2-三大特性" class="headerlink" title="2.2 三大特性"></a>2.2 三大特性</h4><ul><li><p>封装 —— 将若干的数据(变量, 方法, 类) 封装为一个整体。</p></li><li><p>继承 —— 从某个资源中继承它的资源 (资源复用, 资源扩展)。</p></li><li><p>多态 —— 某个事物的多种形态、某种行为不同的表达方式。</p></li></ul><h4 id="三、注释"><a href="#三、注释" class="headerlink" title="三、注释"></a>三、注释</h4><blockquote><p>//单行注释</p></blockquote><blockquote><p>/*<br>    多行注释<br>    多行注释<br>    多行注释<br>    多行注释<br>*/</p></blockquote><pre><code>文档注释：    /**     *    @param  参数名     *    @return  指明返回值的含义     *    @exception  完整类名     *    @deprecated  不建议使用、将来可能摈弃的说明     */生成文档注释：javadoc        -d            apidoc        -windowtitle  标题        -doctitle     文档标题        xx.java       Java 源文件 </code></pre><h4 id="四、JVM、JRE、JDK"><a href="#四、JVM、JRE、JDK" class="headerlink" title="四、JVM、JRE、JDK"></a>四、JVM、JRE、JDK</h4><ol><li><p>什么是JVM？</p><p>Java Virtual Machine，Java虚拟机。</p></li><li><p>什么是JRE？</p><p>Java运行时环境：JavaSE（基础类库）+ JVM</p></li><li><p>什么是JDK？</p><p>Java开发工具包：JRE + 开发工具</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2020/07/01/javascript/"/>
      <url>/2020/07/01/javascript/</url>
      
        <content type="html"><![CDATA[<h3 id="1-为什么要学JavaScript？"><a href="#1-为什么要学JavaScript？" class="headerlink" title="1. 为什么要学JavaScript？"></a>1. 为什么要学JavaScript？</h3><ul><li>表单的注册 —— 表单的页面验证（减轻服务器的压力）</li><li>页面动态效果 —— 树形菜单的使用</li><li>页面内容的动态展示 —— 表单的动态验证、表格的动态数据</li></ul><h3 id="2-JavaScript的特点"><a href="#2-JavaScript的特点" class="headerlink" title="2. JavaScript的特点"></a>2. JavaScript的特点</h3><ul><li>HTML页面添加交互行为</li><li>语法与 Java 类似</li><li>解释性语言，可以边执行边解释</li></ul><h3 id="3-三大组成部分"><a href="#3-三大组成部分" class="headerlink" title="3. 三大组成部分"></a>3. 三大组成部分</h3><ul><li><p>ECMAScript：<a href="http://baike.baidu.com/view/3986646.htm" target="_blank" rel="noopener">Ecma国际</a>以JavaScript为基础制定了<a href="http://baike.baidu.com/view/810176.htm" target="_blank" rel="noopener">ECMAScript</a>标准。</p><ul><li>（函数）</li></ul></li><li><p>DOM：文档对象模型，简单的说，document对象和文档中其他元素</p><ul><li>（如表单、图像、超链接等）</li></ul></li><li><p>BOM：浏览器对象模型，该对象模型提供了独立于内容、可以与浏览器窗口进行互动的对象结构</p><ul><li>（弹窗）</li></ul></li></ul><h3 id="4-引入位置"><a href="#4-引入位置" class="headerlink" title="4. 引入位置"></a>4. 引入位置</h3><ul><li><p><strong>标签中直接使用</strong></p><ul><li><code>&lt;input name=&quot;btn&quot; type=&quot;button&quot; value=&quot;弹出消息框&quot; onclick=&quot;javascript:alert(&#39;欢迎你&#39;);&quot;/&gt;</code></li></ul></li><li><p><strong>&lt;head&gt;标签中调用</strong></p><ul><li><strong>内部调用</strong>  </li></ul><pre><code>&lt;script type=”text/javascript”&gt;        Javascript语句;&lt;/script&gt;</code></pre><ul><li><p><strong>外部调用</strong></p><p><code>&lt;script language=”JavaScript” src=”路径”&gt;&lt;/script&gt;</code></p></li></ul></li><li><p><strong>页面任意位置</strong></p><ul><li>需要调用的元素要保证解析完成（在body里放在需要调用的元素语句后面，最好放在末尾）</li></ul></li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化输出</title>
      <link href="/2020/06/30/ge-shi-hua-shu-chu/"/>
      <url>/2020/06/30/ge-shi-hua-shu-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><h4 id="System-out-printf-方法的使用"><a href="#System-out-printf-方法的使用" class="headerlink" title="System.out.printf(); 方法的使用"></a>System.out.printf(); 方法的使用</h4><table><thead><tr><th>占位符</th><th>说明</th><th>限定位宽</th><th>输出</th></tr></thead><tbody><tr><td>%s</td><td>以字符串的形式输出</td><td>%8s</td><td>最多8个字符</td></tr><tr><td>%f</td><td>以浮点类型的形式输出</td><td>%[位宽] (.) [保留小数个数]f</td><td></td></tr><tr><td>%c</td><td>以字符类型的形式输出</td><td></td><td></td></tr><tr><td>%d</td><td>以十进制整数形式输出</td><td></td><td></td></tr><tr><td>%o</td><td>以八进制整数形式输出</td><td></td><td></td></tr><tr><td>%x</td><td>以十六进制整数形式输出</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown学习</title>
      <link href="/2020/06/28/markdown-xue-xi/"/>
      <url>/2020/06/28/markdown-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习</h1><h3 id="1-什么是Markdown？"><a href="#1-什么是Markdown？" class="headerlink" title="1.什么是Markdown？"></a>1.什么是Markdown？</h3><p>​        Markdown是一种可以使用普通文本编辑器编写的<a href="https://baike.baidu.com/item/标记语言/5964436" target="_blank" rel="noopener">标记语言</a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>​        Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p><h3 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h3><hr><h4 id="2-1常用语法："><a href="#2-1常用语法：" class="headerlink" title="2.1常用语法："></a>2.1常用语法：</h4><table><thead><tr><th>描述</th><th align="center">输入</th><th align="center">显示效果</th></tr></thead><tbody><tr><td>斜体</td><td align="center">*文本*</td><td align="center"><em>嘤嘤嘤</em></td></tr><tr><td>粗体</td><td align="center">**文本**</td><td align="center"><strong>嘤嘤嘤</strong></td></tr><tr><td>斜体加粗</td><td align="center">***文本***</td><td align="center"><strong><em>嘤嘤嘤</em></strong></td></tr><tr><td>删除线</td><td align="center">~~文本~~</td><td align="center"><del>嘤嘤嘤</del></td></tr><tr><td>链接</td><td align="center">[百度一下](<a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a>)</td><td align="center"><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></td></tr><tr><td>图片</td><td align="center">![图片下方文字](图片地址 &quot;鼠标悬停时显示的文字&quot;)</td><td align="center">ps: 悬停文字可不要</td></tr><tr><td>无序列表</td><td align="center">* 文本</td><td align="center">ps:- 文本 或 + 文本 也行</td></tr><tr><td>有序列表</td><td align="center">1. 文本</td><td align="center"></td></tr><tr><td>引用</td><td align="center">&gt; 文本</td><td align="center">可以嵌套，如&gt;&gt;、&gt;&gt;&gt;……</td></tr><tr><td>分割线</td><td align="center">- - - 或 ***(3个或以上)</td><td align="center"></td></tr><tr><td>代码</td><td align="center">`单行`          ```多行```</td><td align="center"></td></tr></tbody></table><blockquote><blockquote><p>百度百科（引用示例：&gt;&gt;）</p></blockquote></blockquote><pre class="line-numbers language-示例"><code class="language-示例">示例：多行代码展示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>单行代码展示</code></p><pre class="line-numbers language-表格"><code class="language-表格">|表头|表头|表头||---|:--:|---:||内容|内容|内容||内容|内容|内容|第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个 文字默认居左-两边加：表示文字居中-右边加：表示文字居右 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="2-2-转义字符："><a href="#2-2-转义字符：" class="headerlink" title="2.2 转义字符："></a>2.2 转义字符：</h4><ol><li><p>特殊字符需要用转义字符 \ 输出。 </p></li><li><p>HTML中的转义字符：</p></li></ol><table><thead><tr><th>显示结果</th><th>描述</th><th>输入</th><th>实体编号</th></tr></thead><tbody><tr><td>&nbsp;</td><td>空格</td><td>&amp;nbsp;</td><td>&amp;#160;</td></tr><tr><td>&lt;</td><td>小于</td><td>&amp;lt;</td><td>&amp;#60;</td></tr><tr><td>&gt;</td><td>大于</td><td>&amp;gt;</td><td>&amp;#62;</td></tr><tr><td>&amp;</td><td>和</td><td>&amp;amp;</td><td>&amp;#38;</td></tr><tr><td>&quot;</td><td>双引</td><td>&amp;quot;</td><td>&amp;#34;</td></tr><tr><td>&#39;</td><td>单引</td><td>&amp;apos;</td><td>&amp;#39;</td></tr><tr><td>&divide;</td><td>除号</td><td>&amp;divide;</td><td>&amp;#247;</td></tr><tr><td>&copy;</td><td>版权</td><td>&amp;copy;</td><td>&amp;#169;</td></tr><tr><td>&reg;</td><td>注册商标</td><td>&amp;reg;</td><td>&amp;#174;</td></tr></tbody></table><hr><h4 id="2-3-标题"><a href="#2-3-标题" class="headerlink" title="2.3 标题"></a>2.3 标题</h4><p>对应个数的 “#” 来表示标题级别。</p><p># 一级标题（对应&lt;h1 /&gt;）</p><p>## 二级标题（对应&lt;h2 /&gt;）</p><p>### 三级标题（对应&lt;h3 /&gt;）</p><p>#### 四级标题（对应&lt;h4 /&gt;）</p><p>##### 五级标题（对应&lt;h5 /&gt;）</p><p>###### 六级标题（对应&lt;h6 /&gt;）</p><hr>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
